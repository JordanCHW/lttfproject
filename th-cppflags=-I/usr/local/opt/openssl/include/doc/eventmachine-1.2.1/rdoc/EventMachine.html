<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>Module: Object::EM</title>

  <link rel="stylesheet" href="./rdoc.css" type="text/css" media="screen" />

  <script src="./js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/darkfish.js" type="text/javascript" charset="utf-8"></script>

</head>
<body id="top" class="module">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="./lib/em/callback_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/callback.rb">lib/em/callback.rb</a></li>
          
            <li><a href="./lib/em/channel_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/channel.rb">lib/em/channel.rb</a></li>
          
            <li><a href="./lib/em/completion_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/completion.rb">lib/em/completion.rb</a></li>
          
            <li><a href="./lib/em/connection_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/connection.rb">lib/em/connection.rb</a></li>
          
            <li><a href="./lib/em/deferrable_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/deferrable.rb">lib/em/deferrable.rb</a></li>
          
            <li><a href="./lib/em/file_watch_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/file_watch.rb">lib/em/file_watch.rb</a></li>
          
            <li><a href="./lib/em/future_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/future.rb">lib/em/future.rb</a></li>
          
            <li><a href="./lib/em/iterator_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/iterator.rb">lib/em/iterator.rb</a></li>
          
            <li><a href="./lib/em/pool_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/pool.rb">lib/em/pool.rb</a></li>
          
            <li><a href="./lib/em/process_watch_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/process_watch.rb">lib/em/process_watch.rb</a></li>
          
            <li><a href="./lib/em/processes_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/processes.rb">lib/em/processes.rb</a></li>
          
            <li><a href="./lib/em/protocols/header_and_content_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/header_and_content.rb">lib/em/protocols/header_and_content.rb</a></li>
          
            <li><a href="./lib/em/protocols/httpclient_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/httpclient.rb">lib/em/protocols/httpclient.rb</a></li>
          
            <li><a href="./lib/em/protocols/httpclient2_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/httpclient2.rb">lib/em/protocols/httpclient2.rb</a></li>
          
            <li><a href="./lib/em/protocols/line_and_text_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/line_and_text.rb">lib/em/protocols/line_and_text.rb</a></li>
          
            <li><a href="./lib/em/protocols/line_protocol_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/line_protocol.rb">lib/em/protocols/line_protocol.rb</a></li>
          
            <li><a href="./lib/em/protocols/linetext2_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/linetext2.rb">lib/em/protocols/linetext2.rb</a></li>
          
            <li><a href="./lib/em/protocols/memcache_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/memcache.rb">lib/em/protocols/memcache.rb</a></li>
          
            <li><a href="./lib/em/protocols/object_protocol_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/object_protocol.rb">lib/em/protocols/object_protocol.rb</a></li>
          
            <li><a href="./lib/em/protocols/postgres3_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/postgres3.rb">lib/em/protocols/postgres3.rb</a></li>
          
            <li><a href="./lib/em/protocols/saslauth_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/saslauth.rb">lib/em/protocols/saslauth.rb</a></li>
          
            <li><a href="./lib/em/protocols/smtpclient_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/smtpclient.rb">lib/em/protocols/smtpclient.rb</a></li>
          
            <li><a href="./lib/em/protocols/smtpserver_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/smtpserver.rb">lib/em/protocols/smtpserver.rb</a></li>
          
            <li><a href="./lib/em/protocols/socks4_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/socks4.rb">lib/em/protocols/socks4.rb</a></li>
          
            <li><a href="./lib/em/protocols/stomp_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/stomp.rb">lib/em/protocols/stomp.rb</a></li>
          
            <li><a href="./lib/em/protocols/tcptest_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols/tcptest.rb">lib/em/protocols/tcptest.rb</a></li>
          
            <li><a href="./lib/em/protocols_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/protocols.rb">lib/em/protocols.rb</a></li>
          
            <li><a href="./lib/em/pure_ruby_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/pure_ruby.rb">lib/em/pure_ruby.rb</a></li>
          
            <li><a href="./lib/em/queue_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/queue.rb">lib/em/queue.rb</a></li>
          
            <li><a href="./lib/em/resolver_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/resolver.rb">lib/em/resolver.rb</a></li>
          
            <li><a href="./lib/em/spawnable_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/spawnable.rb">lib/em/spawnable.rb</a></li>
          
            <li><a href="./lib/em/streamer_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/streamer.rb">lib/em/streamer.rb</a></li>
          
            <li><a href="./lib/em/threaded_resource_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/threaded_resource.rb">lib/em/threaded_resource.rb</a></li>
          
            <li><a href="./lib/em/tick_loop_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/tick_loop.rb">lib/em/tick_loop.rb</a></li>
          
            <li><a href="./lib/em/timers_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/em/timers.rb">lib/em/timers.rb</a></li>
          
            <li><a href="./lib/eventmachine_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/eventmachine.rb">lib/eventmachine.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      

      

      
      <!-- Namespace Contents -->
      <div id="namespace-list-section" class="section">
        <h3 class="section-header">Namespace</h3>
        <ul class="link-list">
          
          <li><span class="type">MODULE</span> <a href="EventMachine/DNS.html">EventMachine::DNS</a></li>
          
          <li><span class="type">MODULE</span> <a href="EventMachine/Deferrable.html">EventMachine::Deferrable</a></li>
          
          <li><span class="type">MODULE</span> <a href="EventMachine/Protocols.html">EventMachine::Protocols</a></li>
          
          <li><span class="type">MODULE</span> <a href="EventMachine/UuidGenerator.html">EventMachine::UuidGenerator</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/CertificateCreator.html">EventMachine::CertificateCreator</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Channel.html">EventMachine::Channel</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Completion.html">EventMachine::Completion</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Connection.html">EventMachine::Connection</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/ConnectionError.html">EventMachine::ConnectionError</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/ConnectionNotBound.html">EventMachine::ConnectionNotBound</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/DatagramObject.html">EventMachine::DatagramObject</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/DefaultDeferrable.html">EventMachine::DefaultDeferrable</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/DeferrableChildProcess.html">EventMachine::DeferrableChildProcess</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Error.html">EventMachine::Error</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/EvmaKeyboard.html">EventMachine::EvmaKeyboard</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/EvmaTCPClient.html">EventMachine::EvmaTCPClient</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/EvmaTCPServer.html">EventMachine::EvmaTCPServer</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/EvmaUDPSocket.html">EventMachine::EvmaUDPSocket</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/EvmaUNIXClient.html">EventMachine::EvmaUNIXClient</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/EvmaUNIXServer.html">EventMachine::EvmaUNIXServer</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/FileNotFoundException.html">EventMachine::FileNotFoundException</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/FileStreamer.html">EventMachine::FileStreamer</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/FileWatch.html">EventMachine::FileWatch</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Iterator.html">EventMachine::Iterator</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/LoopbreakReader.html">EventMachine::LoopbreakReader</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/PeriodicTimer.html">EventMachine::PeriodicTimer</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Pool.html">EventMachine::Pool</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/ProcessWatch.html">EventMachine::ProcessWatch</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Queue.html">EventMachine::Queue</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Reactor.html">EventMachine::Reactor</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Selectable.html">EventMachine::Selectable</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/SpawnedProcess.html">EventMachine::SpawnedProcess</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/StreamObject.html">EventMachine::StreamObject</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/SystemCmd.html">EventMachine::SystemCmd</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/ThreadedResource.html">EventMachine::ThreadedResource</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/TickLoop.html">EventMachine::TickLoop</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Timer.html">EventMachine::Timer</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/UnknownTimerFired.html">EventMachine::UnknownTimerFired</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/Unsupported.html">EventMachine::Unsupported</a></li>
          
          <li><span class="type">CLASS</span> <a href="EventMachine/YieldBlockFromSpawnedProcess.html">EventMachine::YieldBlockFromSpawnedProcess</a></li>
          
        </ul>
      </div>
      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-Callback">::Callback</a></li>
          
          <li><a href="#method-c-_open_file_for_writing">::_open_file_for_writing</a></li>
          
          <li><a href="#method-c-add_oneshot_timer">::add_oneshot_timer</a></li>
          
          <li><a href="#method-c-add_periodic_timer">::add_periodic_timer</a></li>
          
          <li><a href="#method-c-add_shutdown_hook">::add_shutdown_hook</a></li>
          
          <li><a href="#method-c-add_timer">::add_timer</a></li>
          
          <li><a href="#method-c-attach">::attach</a></li>
          
          <li><a href="#method-c-attach_io">::attach_io</a></li>
          
          <li><a href="#method-c-attach_server">::attach_server</a></li>
          
          <li><a href="#method-c-bind_connect">::bind_connect</a></li>
          
          <li><a href="#method-c-bind_connect_server">::bind_connect_server</a></li>
          
          <li><a href="#method-c-cancel_timer">::cancel_timer</a></li>
          
          <li><a href="#method-c-cleanup_machine">::cleanup_machine</a></li>
          
          <li><a href="#method-c-close_connection">::close_connection</a></li>
          
          <li><a href="#method-c-connect">::connect</a></li>
          
          <li><a href="#method-c-connect_server">::connect_server</a></li>
          
          <li><a href="#method-c-connect_unix_domain">::connect_unix_domain</a></li>
          
          <li><a href="#method-c-connect_unix_server">::connect_unix_server</a></li>
          
          <li><a href="#method-c-connection_count">::connection_count</a></li>
          
          <li><a href="#method-c-defer">::defer</a></li>
          
          <li><a href="#method-c-defers_finished-3F">::defers_finished?</a></li>
          
          <li><a href="#method-c-disable_proxy">::disable_proxy</a></li>
          
          <li><a href="#method-c-enable_proxy">::enable_proxy</a></li>
          
          <li><a href="#method-c-epoll">::epoll</a></li>
          
          <li><a href="#method-c-error_handler">::error_handler</a></li>
          
          <li><a href="#method-c-event_callback">::event_callback</a></li>
          
          <li><a href="#method-c-fork_reactor">::fork_reactor</a></li>
          
          <li><a href="#method-c-get_cipher_bits">::get_cipher_bits</a></li>
          
          <li><a href="#method-c-get_cipher_name">::get_cipher_name</a></li>
          
          <li><a href="#method-c-get_cipher_protocol">::get_cipher_protocol</a></li>
          
          <li><a href="#method-c-get_max_timers">::get_max_timers</a></li>
          
          <li><a href="#method-c-get_outbound_data_size">::get_outbound_data_size</a></li>
          
          <li><a href="#method-c-get_peer_cert">::get_peer_cert</a></li>
          
          <li><a href="#method-c-get_peername">::get_peername</a></li>
          
          <li><a href="#method-c-get_sni_hostname">::get_sni_hostname</a></li>
          
          <li><a href="#method-c-get_sock_opt">::get_sock_opt</a></li>
          
          <li><a href="#method-c-heartbeat_interval">::heartbeat_interval</a></li>
          
          <li><a href="#method-c-heartbeat_interval-3D">::heartbeat_interval=</a></li>
          
          <li><a href="#method-c-initialize_event_machine">::initialize_event_machine</a></li>
          
          <li><a href="#method-c-klass_from_handler">::klass_from_handler</a></li>
          
          <li><a href="#method-c-library_type">::library_type</a></li>
          
          <li><a href="#method-c-next_tick">::next_tick</a></li>
          
          <li><a href="#method-c-open_datagram_socket">::open_datagram_socket</a></li>
          
          <li><a href="#method-c-open_keyboard">::open_keyboard</a></li>
          
          <li><a href="#method-c-open_udp_socket">::open_udp_socket</a></li>
          
          <li><a href="#method-c-popen">::popen</a></li>
          
          <li><a href="#method-c-reactor_running-3F">::reactor_running?</a></li>
          
          <li><a href="#method-c-reactor_thread-3F">::reactor_thread?</a></li>
          
          <li><a href="#method-c-read_keyboard">::read_keyboard</a></li>
          
          <li><a href="#method-c-reconnect">::reconnect</a></li>
          
          <li><a href="#method-c-release_machine">::release_machine</a></li>
          
          <li><a href="#method-c-run">::run</a></li>
          
          <li><a href="#method-c-run_block">::run_block</a></li>
          
          <li><a href="#method-c-run_deferred_callbacks">::run_deferred_callbacks</a></li>
          
          <li><a href="#method-c-run_machine">::run_machine</a></li>
          
          <li><a href="#method-c-schedule">::schedule</a></li>
          
          <li><a href="#method-c-send_data">::send_data</a></li>
          
          <li><a href="#method-c-send_datagram">::send_datagram</a></li>
          
          <li><a href="#method-c-send_file_data">::send_file_data</a></li>
          
          <li><a href="#method-c-set_comm_inactivity_timeout">::set_comm_inactivity_timeout</a></li>
          
          <li><a href="#method-c-set_descriptor_table_size">::set_descriptor_table_size</a></li>
          
          <li><a href="#method-c-set_effective_user">::set_effective_user</a></li>
          
          <li><a href="#method-c-set_max_timer_count">::set_max_timer_count</a></li>
          
          <li><a href="#method-c-set_max_timers">::set_max_timers</a></li>
          
          <li><a href="#method-c-set_pending_connect_timeout">::set_pending_connect_timeout</a></li>
          
          <li><a href="#method-c-set_quantum">::set_quantum</a></li>
          
          <li><a href="#method-c-set_rlimit_nofile">::set_rlimit_nofile</a></li>
          
          <li><a href="#method-c-set_sock_opt">::set_sock_opt</a></li>
          
          <li><a href="#method-c-set_timer_quantum">::set_timer_quantum</a></li>
          
          <li><a href="#method-c-set_tls_parms">::set_tls_parms</a></li>
          
          <li><a href="#method-c-signal_loopbreak">::signal_loopbreak</a></li>
          
          <li><a href="#method-c-spawn">::spawn</a></li>
          
          <li><a href="#method-c-spawn_threadpool">::spawn_threadpool</a></li>
          
          <li><a href="#method-c-ssl-3F">::ssl?</a></li>
          
          <li><a href="#method-c-start_server">::start_server</a></li>
          
          <li><a href="#method-c-start_tcp_server">::start_tcp_server</a></li>
          
          <li><a href="#method-c-start_tls">::start_tls</a></li>
          
          <li><a href="#method-c-start_unix_domain_server">::start_unix_domain_server</a></li>
          
          <li><a href="#method-c-start_unix_server">::start_unix_server</a></li>
          
          <li><a href="#method-c-stop">::stop</a></li>
          
          <li><a href="#method-c-stop_event_loop">::stop_event_loop</a></li>
          
          <li><a href="#method-c-stop_server">::stop_server</a></li>
          
          <li><a href="#method-c-stop_tcp_server">::stop_tcp_server</a></li>
          
          <li><a href="#method-c-stopping-3F">::stopping?</a></li>
          
          <li><a href="#method-c-system">::system</a></li>
          
          <li><a href="#method-c-tick_loop">::tick_loop</a></li>
          
          <li><a href="#method-c-tls_parm_set-3F">::tls_parm_set?</a></li>
          
          <li><a href="#method-c-watch">::watch</a></li>
          
          <li><a href="#method-c-watch_file">::watch_file</a></li>
          
          <li><a href="#method-c-watch_process">::watch_process</a></li>
          
          <li><a href="#method-c-yield">::yield</a></li>
          
          <li><a href="#method-c-yield_and_notify">::yield_and_notify</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul>
        
          <li class="file"><a href="./docs/old/ChangeLog.html">ChangeLog</a></li>
        
          <li class="file"><a href="./docs/old/DEFERRABLES.html">DEFERRABLES</a></li>
        
          <li class="file"><a href="./docs/old/EPOLL.html">EPOLL</a></li>
        
          <li class="file"><a href="./docs/old/INSTALL.html">INSTALL</a></li>
        
          <li class="file"><a href="./docs/old/KEYBOARD.html">KEYBOARD</a></li>
        
          <li class="file"><a href="./docs/old/LEGAL.html">LEGAL</a></li>
        
          <li class="file"><a href="./docs/old/LIGHTWEIGHT_CONCURRENCY.html">LIGHTWEIGHT_CONCURRENCY</a></li>
        
          <li class="file"><a href="./docs/old/PURE_RUBY.html">PURE_RUBY</a></li>
        
          <li class="file"><a href="./docs/old/RELEASE_NOTES.html">RELEASE_NOTES</a></li>
        
          <li class="file"><a href="./docs/old/SMTP.html">SMTP</a></li>
        
          <li class="file"><a href="./docs/old/SPAWNED_PROCESSES.html">SPAWNED_PROCESSES</a></li>
        
          <li class="file"><a href="./docs/old/TODO.html">TODO</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="./EventMachine.html">EventMachine</a></li>
        
          <li><a href="./EventMachine.html">EventMachine</a></li>
        
          <li><a href="./EventMachine/CertificateCreator.html">EventMachine::CertificateCreator</a></li>
        
          <li><a href="./EventMachine/Channel.html">EventMachine::Channel</a></li>
        
          <li><a href="./EventMachine/Completion.html">EventMachine::Completion</a></li>
        
          <li><a href="./EventMachine/Connection.html">EventMachine::Connection</a></li>
        
          <li><a href="./EventMachine/ConnectionError.html">EventMachine::ConnectionError</a></li>
        
          <li><a href="./EventMachine/ConnectionNotBound.html">EventMachine::ConnectionNotBound</a></li>
        
          <li><a href="./EventMachine/DNS.html">EventMachine::DNS</a></li>
        
          <li><a href="./EventMachine/DNS/Request.html">EventMachine::DNS::Request</a></li>
        
          <li><a href="./EventMachine/DNS/RequestIdAlreadyUsed.html">EventMachine::DNS::RequestIdAlreadyUsed</a></li>
        
          <li><a href="./EventMachine/DNS/Resolver.html">EventMachine::DNS::Resolver</a></li>
        
          <li><a href="./EventMachine/DNS/Socket.html">EventMachine::DNS::Socket</a></li>
        
          <li><a href="./EventMachine/DatagramObject.html">EventMachine::DatagramObject</a></li>
        
          <li><a href="./EventMachine/DefaultDeferrable.html">EventMachine::DefaultDeferrable</a></li>
        
          <li><a href="./EventMachine/Deferrable.html">EventMachine::Deferrable</a></li>
        
          <li><a href="./EventMachine/DeferrableChildProcess.html">EventMachine::DeferrableChildProcess</a></li>
        
          <li><a href="./EventMachine/Error.html">EventMachine::Error</a></li>
        
          <li><a href="./EventMachine/EvmaKeyboard.html">EventMachine::EvmaKeyboard</a></li>
        
          <li><a href="./EventMachine/EvmaTCPClient.html">EventMachine::EvmaTCPClient</a></li>
        
          <li><a href="./EventMachine/EvmaTCPServer.html">EventMachine::EvmaTCPServer</a></li>
        
          <li><a href="./EventMachine/EvmaUDPSocket.html">EventMachine::EvmaUDPSocket</a></li>
        
          <li><a href="./EventMachine/EvmaUNIXClient.html">EventMachine::EvmaUNIXClient</a></li>
        
          <li><a href="./EventMachine/EvmaUNIXServer.html">EventMachine::EvmaUNIXServer</a></li>
        
          <li><a href="./EventMachine/FileNotFoundException.html">EventMachine::FileNotFoundException</a></li>
        
          <li><a href="./EventMachine/FileStreamer.html">EventMachine::FileStreamer</a></li>
        
          <li><a href="./EventMachine/FileWatch.html">EventMachine::FileWatch</a></li>
        
          <li><a href="./EventMachine/Iterator.html">EventMachine::Iterator</a></li>
        
          <li><a href="./EventMachine/LoopbreakReader.html">EventMachine::LoopbreakReader</a></li>
        
          <li><a href="./EventMachine/PeriodicTimer.html">EventMachine::PeriodicTimer</a></li>
        
          <li><a href="./EventMachine/Pool.html">EventMachine::Pool</a></li>
        
          <li><a href="./EventMachine/ProcessWatch.html">EventMachine::ProcessWatch</a></li>
        
          <li><a href="./EventMachine/Protocols.html">EventMachine::Protocols</a></li>
        
          <li><a href="./EventMachine/Protocols.html">EventMachine::Protocols</a></li>
        
          <li><a href="./EventMachine/Protocols/HeaderAndContentProtocol.html">EventMachine::Protocols::HeaderAndContentProtocol</a></li>
        
          <li><a href="./EventMachine/Protocols/HttpClient.html">EventMachine::Protocols::HttpClient</a></li>
        
          <li><a href="./EventMachine/Protocols/HttpClient2.html">EventMachine::Protocols::HttpClient2</a></li>
        
          <li><a href="./EventMachine/Protocols/HttpClient2/Request.html">EventMachine::Protocols::HttpClient2::Request</a></li>
        
          <li><a href="./EventMachine/Protocols/LineAndTextProtocol.html">EventMachine::Protocols::LineAndTextProtocol</a></li>
        
          <li><a href="./EventMachine/Protocols/LineProtocol.html">EventMachine::Protocols::LineProtocol</a></li>
        
          <li><a href="./EventMachine/Protocols/LineText2.html">EventMachine::Protocols::LineText2</a></li>
        
          <li><a href="./EventMachine/Protocols/Memcache.html">EventMachine::Protocols::Memcache</a></li>
        
          <li><a href="./EventMachine/Protocols/Memcache/ParserError.html">EventMachine::Protocols::Memcache::ParserError</a></li>
        
          <li><a href="./EventMachine/Protocols/ObjectProtocol.html">EventMachine::Protocols::ObjectProtocol</a></li>
        
          <li><a href="./EventMachine/Protocols/Postgres3.html">EventMachine::Protocols::Postgres3</a></li>
        
          <li><a href="./EventMachine/Protocols/SASLauth.html">EventMachine::Protocols::SASLauth</a></li>
        
          <li><a href="./EventMachine/Protocols/SASLauthclient.html">EventMachine::Protocols::SASLauthclient</a></li>
        
          <li><a href="./EventMachine/Protocols/SmtpClient.html">EventMachine::Protocols::SmtpClient</a></li>
        
          <li><a href="./EventMachine/Protocols/SmtpServer.html">EventMachine::Protocols::SmtpServer</a></li>
        
          <li><a href="./EventMachine/Protocols/Socks4.html">EventMachine::Protocols::Socks4</a></li>
        
          <li><a href="./EventMachine/Protocols/Stomp.html">EventMachine::Protocols::Stomp</a></li>
        
          <li><a href="./EventMachine/Protocols/Stomp/Message.html">EventMachine::Protocols::Stomp::Message</a></li>
        
          <li><a href="./EventMachine/Protocols/TcpConnectTester.html">EventMachine::Protocols::TcpConnectTester</a></li>
        
          <li><a href="./EventMachine/Queue.html">EventMachine::Queue</a></li>
        
          <li><a href="./EventMachine/Reactor.html">EventMachine::Reactor</a></li>
        
          <li><a href="./EventMachine/Selectable.html">EventMachine::Selectable</a></li>
        
          <li><a href="./EventMachine/SpawnedProcess.html">EventMachine::SpawnedProcess</a></li>
        
          <li><a href="./EventMachine/StreamObject.html">EventMachine::StreamObject</a></li>
        
          <li><a href="./EventMachine/SystemCmd.html">EventMachine::SystemCmd</a></li>
        
          <li><a href="./EventMachine/ThreadedResource.html">EventMachine::ThreadedResource</a></li>
        
          <li><a href="./EventMachine/TickLoop.html">EventMachine::TickLoop</a></li>
        
          <li><a href="./EventMachine/Timer.html">EventMachine::Timer</a></li>
        
          <li><a href="./EventMachine/UnknownTimerFired.html">EventMachine::UnknownTimerFired</a></li>
        
          <li><a href="./EventMachine/Unsupported.html">EventMachine::Unsupported</a></li>
        
          <li><a href="./EventMachine/UuidGenerator.html">EventMachine::UuidGenerator</a></li>
        
          <li><a href="./EventMachine/YieldBlockFromSpawnedProcess.html">EventMachine::YieldBlockFromSpawnedProcess</a></li>
        
          <li><a href="./Object.html">Object</a></li>
        
          <li><a href="./EventMachine.html">Object::EM</a></li>
        
          <li><a href="./EventMachine/Protocols.html">Object::P</a></li>
        
          <li><a href="./BufferedTokenizer.html">BufferedTokenizer</a></li>
        
          <li><a href="./IO.html">IO</a></li>
        
          <li><a href="./StringIO.html">StringIO</a></li>
        
          <li><a href="./TestConnection.html">TestConnection</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="module">Object::EM</h1>

    <div id="description" class="description">
      
<h1><a href="EventMachine/Completion.html">EM::Completion</a></h1>

<p>A completion is a callback container for various states of completion. In
its most basic form it has a start state and a finish state.</p>

<p>This implementation includes some hold-back from the <a
href="EventMachine/Deferrable.html">EM::Deferrable</a> interface in order
to be compatible - but it has a much cleaner implementation.</p>

<p>In general it is preferred that this implementation be used as a state
callback container than <a
href="EventMachine/DefaultDeferrable.html">EM::DefaultDeferrable</a> or
other classes including <a
href="EventMachine/Deferrable.html">EM::Deferrable</a>. This is because it
is generally more sane to keep this level of state in a dedicated
state-back container. This generally leads to more malleable interfaces and
software designs, as well as eradicating nasty bugs that result from
abstraction leakage.</p>

<h2>Basic Usage</h2>

<p>As already mentioned, the basic usage of a <a
href="EventMachine/Completion.html">Completion</a> is simply for its two
final states, :succeeded and :failed.</p>

<p>An asynchronous operation will complete at some future point in time, and
users often want to react to this event. API authors will want to expose
some common interface to react to these events.</p>

<p>In the following example, the user wants to know when a short lived
connection has completed its exchange with the remote server. The simple
protocol just waits for an ack to its message.</p>

<pre>class Protocol &lt; EM::Connection
  include EM::P::LineText2

  def initialize(message, completion)
    @message, @completion = message, completion
    @completion.completion { close_connection }
    @completion.timeout(1, :timeout)
  end

  def post_init
    send_data(@message)
  end

  def receive_line(line)
    case line
    when /ACK/i
      @completion.succeed line
    when /ERR/i
      @completion.fail :error, line
    else
      @completion.fail :unknown, line
    end
  end

  def unbind
    @completion.fail :disconnected unless @completion.completed?
  end
end

class API
  attr_reader :host, :port

  def initialize(host = 'example.org', port = 8000)
    @host, @port = host, port
  end

  def request(message)
    completion = EM::Deferrable::Completion.new
    EM.connect(host, port, Protocol, message, completion)
    completion
  end
end

api = API.new
completion = api.request('stuff')
completion.callback do |line|
  puts &quot;API responded with: #{line}&quot;
end
completion.errback do |type, line|
  case type
  when :error
    puts &quot;API error: #{line}&quot;
  when :unknown
    puts &quot;API returned unknown response: #{line}&quot;
  when :disconnected
    puts &quot;API server disconnected prematurely&quot;
  when :timeout
    puts &quot;API server did not respond in a timely fashion&quot;
  end
end</pre>

<h2>Advanced Usage</h2>

<p>This completion implementation also supports more state callbacks and
arbitrary states (unlike the original <a
href="EventMachine/Deferrable.html">Deferrable</a> API). This allows for
basic stateful process encapsulation. One might use this to setup state
callbacks for various states in an exchange like in the basic usage
example, except where the applicaiton could be made to react to “connected”
and “disconnected” states additionally.</p>

<pre>class Protocol &lt; EM::Connection
  def initialize(completion)
    @response = []
    @completion = completion
    @completion.stateback(:disconnected) do
      @completion.succeed @response.join
    end
  end

  def connection_completed
    @host, @port = Socket.unpack_sockaddr_in get_peername
    @completion.change_state(:connected, @host, @port)
    send_data(&quot;GET http://example.org/ HTTP/1.0\r\n\r\n&quot;)
  end

  def receive_data(data)
    @response &lt;&lt; data
  end

  def unbind
    @completion.change_state(:disconnected, @host, @port)
  end
end

completion = EM::Deferrable::Completion.new
completion.stateback(:connected) do |host, port|
  puts &quot;Connected to #{host}:#{port}&quot;
end
completion.stateback(:disconnected) do |host, port|
  puts &quot;Disconnected from #{host}:#{port}&quot;
end
completion.callback do |response|
  puts response
end

EM.connect('example.org', 80, Protocol, completion)</pre>

<h2>Timeout</h2>

<p>The <a href="EventMachine/Completion.html">Completion</a> also has a
timeout. The timeout is global and is not aware of states apart from
completion states. The timeout is only engaged if timeout is called, and it
will call fail if it is reached.</p>

<h2><a href="EventMachine/Completion.html">Completion</a> states</h2>

<p>By default there are two completion states, :succeeded and :failed. These
states can be modified by subclassing and overrding the completion_states
method. <a href="EventMachine/Completion.html">Completion</a> states are
special, in that callbacks for all completion states are explcitly cleared
when a completion state is entered. This prevents errors that could arise
from accidental unterminated timeouts, and other such user errors.</p>

<h2>Other notes</h2>

<p>Several APIs have been carried over from <a
href="EventMachine/Deferrable.html">EM::Deferrable</a> for compatibility
reasons during a transitionary period. Specifically cancel_errback and
cancel_callback are implemented, but their usage is to be strongly
discouraged. Due to the already complex nature of reaction systems, dynamic
callback deletion only makes the problem much worse. It is always better to
add correct conditionals to the callback code, or use more states, than to
address such implementaiton issues with conditional callbacks.</p>
<hr style="height: 1px">

<p>@private</p>
<hr style="height: 1px">

<p>@private</p>
<hr style="height: 1px">

<p>Top-level <a href="EventMachine.html">EventMachine</a> namespace. If you
are looking for <a href="EventMachine.html">EventMachine</a> examples, see
{file:<a href="docs/GettingStarted_md.html">docs/GettingStarted.md</a> <a
href="EventMachine.html">EventMachine</a> tutorial}.</p>

<p>## Key methods ## ### Starting and stopping the event loop ###</p>
<ul><li>
<p>{<a href="EventMachine.html#method-c-run">EventMachine.run</a>}</p>
</li><li>
<p>{<a
href="EventMachine.html#method-c-stop_event_loop">EventMachine.stop_event_loop</a>}</p>
</li></ul>

<p>### Implementing clients ###</p>
<ul><li>
<p>{<a href="EventMachine.html#method-c-connect">EventMachine.connect</a>}</p>
</li></ul>

<p>### Implementing servers ###</p>
<ul><li>
<p>{<a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a>}</p>
</li></ul>

<p>### Working with timers ###</p>
<ul><li>
<p>{<a href="EventMachine.html#method-c-add_timer">EventMachine.add_timer</a>}</p>
</li><li>
<p>{<a
href="EventMachine.html#method-c-add_periodic_timer">EventMachine.add_periodic_timer</a>}</p>
</li><li>
<p>{<a
href="EventMachine.html#method-c-cancel_timer">EventMachine.cancel_timer</a>}</p>
</li></ul>

<p>### Working with blocking tasks ###</p>
<ul><li>
<p>{<a href="EventMachine.html#method-c-defer">EventMachine.defer</a>}</p>
</li><li>
<p>{<a href="EventMachine.html#method-c-next_tick">EventMachine.next_tick</a>}</p>
</li></ul>

<p>### Efficient proxying ###</p>
<ul><li>
<p>{<a
href="EventMachine.html#method-c-enable_proxy">EventMachine.enable_proxy</a>}</p>
</li><li>
<p>{<a
href="EventMachine.html#method-c-disable_proxy">EventMachine.disable_proxy</a>}</p>
</li></ul>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="ConnectionAccepted">ConnectionAccepted</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="ConnectionCompleted">ConnectionCompleted</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="ConnectionData">ConnectionData</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="ConnectionNotifyReadable">ConnectionNotifyReadable</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="ConnectionNotifyWritable">ConnectionNotifyWritable</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="ConnectionUnbound">ConnectionUnbound</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="DefaultCertificate">DefaultCertificate</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="DefaultDHKey1024">DefaultDHKey1024</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="DefaultDHKey2048">DefaultDHKey2048</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="EM_PROTO_SSLv2">EM_PROTO_SSLv2</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="EM_PROTO_SSLv3">EM_PROTO_SSLv3</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="EM_PROTO_TLSv1">EM_PROTO_TLSv1</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="EM_PROTO_TLSv1_1">EM_PROTO_TLSv1_1</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="EM_PROTO_TLSv1_2">EM_PROTO_TLSv1_2</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="ERRNOS">ERRNOS</a></dt>
          
          <dd class="description"><p>System errnos @private</p></dd>
          
        
          <dt><a name="LoopbreakSignalled">LoopbreakSignalled</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="SSLConnectionWaitReadable">SSLConnectionWaitReadable</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="SSLConnectionWaitWritable">SSLConnectionWaitWritable</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="SslHandshakeCompleted">SslHandshakeCompleted</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="SslVerify">SslVerify</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
          <dt><a name="TimerFired">TimerFired</a></dt>
          
          <dd class="description"><p>@private</p></dd>
          
        
        </dl>
      </div>
      

      
      <!-- Attributes -->
      <div id="attribute-method-details" class="method-section section">
        <h3 class="section-header">Attributes</h3>

        
        <div id="reactor_thread-attribute-method" class="method-detail">
          <a name="reactor_thread"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">reactor_thread</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>Exposed to allow joining on the thread, when run in a multithreaded
environment. Performing other actions on the thread has undefined semantics
(read: a dangerous endevor).</p>

<p>@return [Thread]</p>
          
          </div>
        </div>
        
        <div id="threadpool-attribute-method" class="method-detail">
          <a name="threadpool"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">threadpool</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>@private</p>
          
          </div>
        </div>
        
        <div id="threadpool_size-attribute-method" class="method-detail">
          <a name="threadpool_size"></a>
          
          <a name="threadpool_size="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">threadpool_size</span><span
              class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Size of the <a
href="EventMachine.html#method-c-defer">EventMachine.defer</a> threadpool
(defaults to 20) @return [Number]</p>
          
          </div>
        </div>
        
      </div><!-- attribute-method-details -->
      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="Callback-method" class="method-detail ">
          <a name="method-c-Callback"></a>

          
          <div class="method-heading">
            <span class="method-name">Callback</span><span
              class="method-args">(object = nil, method = nil, &blk)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Utility method for coercing arguments to an object that responds to :call.
Accepts an object and a method name to send to, or a block, or an object
that responds to :call.</p>

<p>@example <a href="EventMachine.html">EventMachine</a>.<a
href="EventMachine.html#method-c-Callback">Callback</a> used with a block.
Returns that block.</p>

<pre>cb = EventMachine.Callback do |msg|
  puts(msg)
end
# returned object is a callable
cb.call('hello world')</pre>

<p>@example <a href="EventMachine.html">EventMachine</a>.<a
href="EventMachine.html#method-c-Callback">Callback</a> used with an object
(to be more specific, class object) and a method name, returns an object
that responds to call</p>

<pre>cb = EventMachine.Callback(Object, :puts)
# returned object is a callable that delegates to Kernel#puts (in this case Object.puts)
cb.call('hello world')</pre>

<p>@example <a href="EventMachine.html">EventMachine</a>.<a
href="EventMachine.html#method-c-Callback">Callback</a> used with an object
that responds to call. Returns the argument.</p>

<pre>cb = EventMachine.Callback(proc{ |msg| puts(msg) })
# returned object is a callable
cb.call('hello world')</pre>

<p>@overload Callback(object, method)</p>

<pre>Wraps `method` invocation on `object` into an object that responds to #call that proxies all the arguments to that method
@param [Object] Object to invoke method on
@param [Symbol] Method name
@return [&lt;#call&gt;] An object that responds to #call that takes any number of arguments and invokes method on object with those arguments</pre>

<p>@overload Callback(object)</p>

<pre>Returns callable object as is, without any coercion
@param [&lt;#call&gt;] An object that responds to #call
@return [&lt;#call&gt;] Its argument</pre>

<p>@overload Callback(&amp;block)</p>

<pre>Returns block passed to it without any coercion
@return [&lt;#call&gt;] Block passed to this method</pre>

<p>@raise [ArgumentError] When argument doesn’t respond to call, method name
is missing or when invoked without arguments and block isn’t given</p>

<p>@return [&lt;call&gt;]</p>
            

            
            <div class="method-source-code" id="Callback-source">
<pre>
<span class="ruby-comment"># File lib/em/callback.rb, line 47</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-constant">Callback</span>(<span class="ruby-identifier">object</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">method</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">blk</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">object</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">method</span>
    <span class="ruby-identifier">lambda</span> { <span class="ruby-operator">|</span>*<span class="ruby-identifier">args</span><span class="ruby-operator">|</span> <span class="ruby-identifier">object</span>.<span class="ruby-identifier">__send__</span> <span class="ruby-identifier">method</span>, *<span class="ruby-identifier">args</span> }
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">object</span>.<span class="ruby-identifier">respond_to?</span> <span class="ruby-value">:call</span>
      <span class="ruby-identifier">object</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">blk</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>)
    <span class="ruby-keyword">end</span> <span class="ruby-comment"># if</span>
  <span class="ruby-keyword">end</span> <span class="ruby-comment"># if</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- Callback-source -->
            
          </div>

          

          
        </div><!-- Callback-method -->

      
        <div id="_open_file_for_writing-method" class="method-detail ">
          <a name="method-c-_open_file_for_writing"></a>

          
          <div class="method-heading">
            <span class="method-name">_open_file_for_writing</span><span
              class="method-args">(filename, handler=nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="_open_file_for_writing-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1552</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">_open_file_for_writing</span> <span class="ruby-identifier">filename</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-constant">Connection</span>, <span class="ruby-identifier">handler</span>)

  <span class="ruby-identifier">s</span> = <span class="ruby-identifier">_write_file</span> <span class="ruby-identifier">filename</span>
  <span class="ruby-identifier">c</span> = <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">s</span>
  <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">block_given?</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">c</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- _open_file_for_writing-source -->
            
          </div>

          

          
        </div><!-- _open_file_for_writing-method -->

      
        <div id="add_oneshot_timer-method" class="method-detail ">
          <a name="method-c-add_oneshot_timer"></a>

          
          <div class="method-heading">
            <span class="method-name">add_oneshot_timer</span><span
              class="method-args">(interval)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Changed 04Oct06: intervals from the caller are now in milliseconds, but our
native-ruby processor still wants them in seconds. @private</p>
            

            
            <div class="method-source-code" id="add_oneshot_timer-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">add_oneshot_timer</span> <span class="ruby-identifier">interval</span>
  <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">install_oneshot_timer</span>(<span class="ruby-identifier">interval</span> <span class="ruby-operator">/</span> <span class="ruby-value">1000</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- add_oneshot_timer-source -->
            
          </div>

          

          
        </div><!-- add_oneshot_timer-method -->

      
        <div id="add_periodic_timer-method" class="method-detail ">
          <a name="method-c-add_periodic_timer"></a>

          
          <div class="method-heading">
            <span class="method-name">add_periodic_timer</span><span
              class="method-args">(*args, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds a periodic timer to the event loop. It takes the same parameters as
the one-shot timer method, {<a
href="EventMachine.html#method-c-add_timer">EventMachine.add_timer</a>}.
This method schedules execution of the given block repeatedly, at intervals
of time *at least* as great as the number of seconds given in the first
parameter to the call.</p>

<p>@example Write a dollar-sign to stderr every five seconds, without blocking</p>

<pre>EventMachine.run {
  EventMachine.add_periodic_timer( 5 ) { $stderr.write &quot;$&quot; }
}</pre>

<p>@param [Integer] delay Delay in seconds</p>

<p>@see <a
href="EventMachine/PeriodicTimer.html">EventMachine::PeriodicTimer</a> @see
<a href="EventMachine.html#method-c-add_timer">EventMachine.add_timer</a></p>
            

            
            <div class="method-source-code" id="add_periodic_timer-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 350</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">add_periodic_timer</span> *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-identifier">interval</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span>
  <span class="ruby-identifier">code</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">block</span>

  <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-constant">PeriodicTimer</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">interval</span>, <span class="ruby-identifier">code</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- add_periodic_timer-source -->
            
          </div>

          

          
        </div><!-- add_periodic_timer-method -->

      
        <div id="add_shutdown_hook-method" class="method-detail ">
          <a name="method-c-add_shutdown_hook"></a>

          
          <div class="method-heading">
            <span class="method-name">add_shutdown_hook</span><span
              class="method-args">(&block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds a block to call as the reactor is shutting down.</p>

<p>These callbacks are called in the <em>reverse</em> order to which they are
added.</p>

<p>@example Scheduling operations to be run when <a
href="EventMachine.html">EventMachine</a> event loop is stopped</p>

<pre>EventMachine.run do
  EventMachine.add_shutdown_hook { puts &quot;b&quot; }
  EventMachine.add_shutdown_hook { puts &quot;a&quot; }
  EventMachine.stop
end

# Outputs:
#   a
#   b</pre>
            

            
            <div class="method-source-code" id="add_shutdown_hook-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 290</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">add_shutdown_hook</span> &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-ivar">@tails</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- add_shutdown_hook-source -->
            
          </div>

          

          
        </div><!-- add_shutdown_hook-method -->

      
        <div id="add_timer-method" class="method-detail ">
          <a name="method-c-add_timer"></a>

          
          <div class="method-heading">
            <span class="method-name">add_timer</span><span
              class="method-args">(*args, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Adds a one-shot timer to the event loop. Call it with one or two
parameters. The first parameters is a delay-time expressed in
<b>seconds</b> (not milliseconds). The second parameter, if present, must
be an object that responds to :call. If 2nd parameter is not given, then
you can also simply pass a block to the method call.</p>

<p>This method may be called from the block passed to {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>} or from any
callback method. It schedules execution of the proc or block passed to it,
after the passage of an interval of time equal to *at least* the number of
seconds specified in the first parameter to the call.</p>

<p>{<a href="EventMachine.html#method-c-add_timer">EventMachine.add_timer</a>}
is a non-blocking method. Callbacks can and will be called during the
interval of time that the timer is in effect. There is no built-in limit to
the number of timers that can be outstanding at any given time.</p>

<p>@example Setting a one-shot timer with <a
href="EventMachine.html">EventMachine</a></p>

<pre>EventMachine.run {
  puts &quot;Starting the run now: #{Time.now}&quot;
  EventMachine.add_timer 5, proc { puts &quot;Executing timer event: #{Time.now}&quot; }
  EventMachine.add_timer(10) { puts &quot;Executing timer event: #{Time.now}&quot; }
}</pre>

<p>@param [Integer] delay Delay in seconds @see <a
href="EventMachine/Timer.html">EventMachine::Timer</a> @see <a
href="EventMachine.html#method-c-add_periodic_timer">EventMachine.add_periodic_timer</a></p>
            

            
            <div class="method-source-code" id="add_timer-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 322</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">add_timer</span> *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-identifier">interval</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span>
  <span class="ruby-identifier">code</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">block</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">code</span>
    <span class="ruby-comment"># check too many timers!</span>
    <span class="ruby-identifier">s</span> = <span class="ruby-identifier">add_oneshot_timer</span>((<span class="ruby-identifier">interval</span>.<span class="ruby-identifier">to_f</span> * <span class="ruby-value">1000</span>).<span class="ruby-identifier">to_i</span>)
    <span class="ruby-ivar">@timers</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">code</span>
    <span class="ruby-identifier">s</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- add_timer-source -->
            
          </div>

          

          
        </div><!-- add_timer-method -->

      
        <div id="attach-method" class="method-detail ">
          <a name="method-c-attach"></a>

          
          <div class="method-heading">
            <span class="method-name">attach</span><span
              class="method-args">(io, handler=nil, *args, &blk)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Attaches an <a href="IO.html">IO</a> object or file descriptor to the
eventloop as a regular connection. The file descriptor will be set as
non-blocking, and <a href="EventMachine.html">EventMachine</a> will process
receive_data and <a
href="EventMachine.html#method-c-send_data">send_data</a> events on it as
it would for any other connection.</p>

<p>To watch a fd instead, use {<a
href="EventMachine.html#method-c-watch">EventMachine.watch</a>}, which will
not alter the state of the socket and fire notify_readable and
notify_writable events instead.</p>
            

            
            <div class="method-source-code" id="attach-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 740</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">attach</span> <span class="ruby-identifier">io</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">blk</span>
  <span class="ruby-identifier">attach_io</span> <span class="ruby-identifier">io</span>, <span class="ruby-keyword">false</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">blk</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- attach-source -->
            
          </div>

          

          
        </div><!-- attach-method -->

      
        <div id="attach_io-method" class="method-detail ">
          <a name="method-c-attach_io"></a>

          
          <div class="method-heading">
            <span class="method-name">attach_io</span><span
              class="method-args">(io, watch_mode, handler=nil, *args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="attach_io-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 745</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">attach_io</span> <span class="ruby-identifier">io</span>, <span class="ruby-identifier">watch_mode</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-constant">Connection</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">watch_mode</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">public_instance_methods</span>.<span class="ruby-identifier">any?</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> [<span class="ruby-value">:notify_readable</span>, <span class="ruby-value">:notify_writable</span>].<span class="ruby-identifier">include?</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">to_sym</span> }
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;notify_readable/writable with EM.attach is not supported. Use EM.watch(io){ |c| c.notify_readable = true }&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">io</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:fileno</span>)
    <span class="ruby-comment"># getDescriptorByFileno deprecated in JRuby 1.7.x, removed in JRuby 9000</span>
    <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-constant">JRuby</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">JRuby</span>.<span class="ruby-identifier">runtime</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:getDescriptorByFileno</span>)
      <span class="ruby-identifier">fd</span> = <span class="ruby-constant">JRuby</span>.<span class="ruby-identifier">runtime</span>.<span class="ruby-identifier">getDescriptorByFileno</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">fileno</span>).<span class="ruby-identifier">getChannel</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">fd</span> = <span class="ruby-identifier">io</span>.<span class="ruby-identifier">fileno</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">fd</span> = <span class="ruby-identifier">io</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">s</span> = <span class="ruby-identifier">attach_fd</span> <span class="ruby-identifier">fd</span>, <span class="ruby-identifier">watch_mode</span>
  <span class="ruby-identifier">c</span> = <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">s</span>, *<span class="ruby-identifier">args</span>

  <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-value">:@io</span>, <span class="ruby-identifier">io</span>)
  <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-value">:@watch_mode</span>, <span class="ruby-identifier">watch_mode</span>)
  <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-value">:@fd</span>, <span class="ruby-identifier">fd</span>)

  <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">block_given?</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">c</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- attach_io-source -->
            
          </div>

          

          
        </div><!-- attach_io-method -->

      
        <div id="attach_server-method" class="method-detail ">
          <a name="method-c-attach_server"></a>

          
          <div class="method-heading">
            <span class="method-name">attach_server</span><span
              class="method-args">(sock, handler=nil, *args, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Attach to an existing socket’s file descriptor. The socket may have been
started with {<a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a>}.</p>
            

            
            <div class="method-source-code" id="attach_server-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 540</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">attach_server</span> <span class="ruby-identifier">sock</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-constant">Connection</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">sd</span> = <span class="ruby-identifier">sock</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:fileno</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">sock</span>.<span class="ruby-identifier">fileno</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sock</span>
  <span class="ruby-identifier">s</span> = <span class="ruby-identifier">attach_sd</span>(<span class="ruby-identifier">sd</span>)
  <span class="ruby-ivar">@acceptors</span>[<span class="ruby-identifier">s</span>] = [<span class="ruby-identifier">klass</span>,<span class="ruby-identifier">args</span>,<span class="ruby-identifier">block</span>,<span class="ruby-identifier">sock</span>]
  <span class="ruby-identifier">s</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- attach_server-source -->
            
          </div>

          

          
        </div><!-- attach_server-method -->

      
        <div id="bind_connect-method" class="method-detail ">
          <a name="method-c-bind_connect"></a>

          
          <div class="method-heading">
            <span class="method-name">bind_connect</span><span
              class="method-args">(bind_addr, bind_port, server, port=nil, handler=nil, *args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This method is like {<a
href="EventMachine.html#method-c-connect">EventMachine.connect</a>}, but
allows for a local address/port to bind the connection to.</p>

<p>@see <a href="EventMachine.html#method-c-connect">EventMachine.connect</a></p>
            

            
            <div class="method-source-code" id="bind_connect-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 660</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">bind_connect</span> <span class="ruby-identifier">bind_addr</span>, <span class="ruby-identifier">bind_port</span>, <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">port</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-identifier">port</span>)
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-constant">TypeError</span>
    <span class="ruby-comment"># there was no port, so server must be a unix domain socket</span>
    <span class="ruby-comment"># the port argument is actually the handler, and the handler is one of the args</span>
    <span class="ruby-identifier">args</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">handler</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">handler</span>
    <span class="ruby-identifier">handler</span> = <span class="ruby-identifier">port</span>
    <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">port</span>

  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-constant">Connection</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>)

  <span class="ruby-identifier">s</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">port</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">bind_addr</span>
          <span class="ruby-identifier">bind_connect_server</span> <span class="ruby-identifier">bind_addr</span>, <span class="ruby-identifier">bind_port</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">connect_server</span> <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">connect_unix_server</span> <span class="ruby-identifier">server</span>
      <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">c</span> = <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">s</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">block_given?</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">c</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- bind_connect-source -->
            
          </div>

          

          
        </div><!-- bind_connect-method -->

      
        <div id="bind_connect_server-method" class="method-detail ">
          <a name="method-c-bind_connect_server"></a>

          
          <div class="method-heading">
            <span class="method-name">bind_connect_server</span><span
              class="method-args">(bind_addr, bind_port, host, port)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="bind_connect_server-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">bind_connect_server</span> <span class="ruby-identifier">bind_addr</span>, <span class="ruby-identifier">bind_port</span>, <span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>
  <span class="ruby-constant">EvmaTCPClient</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-identifier">bind_addr</span>, <span class="ruby-identifier">bind_port</span>, <span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>).<span class="ruby-identifier">uuid</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- bind_connect_server-source -->
            
          </div>

          

          
        </div><!-- bind_connect_server-method -->

      
        <div id="cancel_timer-method" class="method-detail ">
          <a name="method-c-cancel_timer"></a>

          
          <div class="method-heading">
            <span class="method-name">cancel_timer</span><span
              class="method-args">(timer_or_sig)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Cancel a timer (can be a callback or an {EventMachine::Timer} instance).</p>

<p>@param [cancel, call] timer_or_sig A timer to cancel @see <a
href="EventMachine/Timer.html#method-i-cancel">EventMachine::Timer#cancel</a></p>
            

            
            <div class="method-source-code" id="cancel_timer-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 362</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cancel_timer</span> <span class="ruby-identifier">timer_or_sig</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">timer_or_sig</span>.<span class="ruby-identifier">respond_to?</span> <span class="ruby-value">:cancel</span>
    <span class="ruby-identifier">timer_or_sig</span>.<span class="ruby-identifier">cancel</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@timers</span>[<span class="ruby-identifier">timer_or_sig</span>] = <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@timers</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">timer_or_sig</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- cancel_timer-source -->
            
          </div>

          

          
        </div><!-- cancel_timer-method -->

      
        <div id="cleanup_machine-method" class="method-detail ">
          <a name="method-c-cleanup_machine"></a>

          
          <div class="method-heading">
            <span class="method-name">cleanup_machine</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Clean up Ruby space following a <a
href="EventMachine.html#method-c-release_machine">release_machine</a></p>
            

            
            <div class="method-source-code" id="cleanup_machine-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 260</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cleanup_machine</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@threadpool</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@threadpool</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-comment"># Tell the threads to stop</span>
    <span class="ruby-ivar">@threadpool</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-identifier">t</span>.<span class="ruby-identifier">exit</span> }
    <span class="ruby-comment"># Join the threads or bump the stragglers one more time</span>
    <span class="ruby-ivar">@threadpool</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-identifier">t</span>.<span class="ruby-identifier">join</span> <span class="ruby-value">0.01</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">t</span>.<span class="ruby-identifier">exit</span> }
  <span class="ruby-keyword">end</span>
  <span class="ruby-ivar">@threadpool</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@threadqueue</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@resultqueue</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@all_threads_spawned</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@next_tick_queue</span> = []
<span class="ruby-keyword">end</span></pre>
            </div><!-- cleanup_machine-source -->
            
          </div>

          

          
        </div><!-- cleanup_machine-method -->

      
        <div id="close_connection-method" class="method-detail ">
          <a name="method-c-close_connection"></a>

          
          <div class="method-heading">
            <span class="method-name">close_connection</span><span
              class="method-args">(target, after_writing)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="close_connection-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">close_connection</span> <span class="ruby-identifier">target</span>, <span class="ruby-identifier">after_writing</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>( <span class="ruby-identifier">target</span> )
  <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">schedule_close</span> <span class="ruby-identifier">after_writing</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">selectable</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- close_connection-source -->
            
          </div>

          

          
        </div><!-- close_connection-method -->

      
        <div id="connect-method" class="method-detail ">
          <a name="method-c-connect"></a>

          
          <div class="method-heading">
            <span class="method-name">connect</span><span
              class="method-args">(server, port=nil, handler=nil, *args, &blk)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Initiates a TCP connection to a remote server and sets up event handling
for the connection. {<a
href="EventMachine.html#method-c-connect">EventMachine.connect</a>}
requires event loop to be running (see {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>}).</p>

<p>{<a href="EventMachine.html#method-c-connect">EventMachine.connect</a>}
takes the IP address (or hostname) and port of the remote server you want
to connect to. It also takes an optional handler (a module or a subclass of
{EventMachine::Connection}) which you must define, that contains the
callbacks that will be invoked by the event loop on behalf of the
connection.</p>

<p>Learn more about connection lifecycle callbacks in the {file:<a
href="docs/GettingStarted_md.html">docs/GettingStarted.md</a> <a
href="EventMachine.html">EventMachine</a> tutorial} and
{file:docs/ConnectionLifecycleCallbacks.md <a
href="EventMachine/Connection.html">Connection</a> lifecycle guide}.</p>

<p>@example</p>

<pre># Here's a program which connects to a web server, sends a naive
# request, parses the HTTP header of the response, and then
# (antisocially) ends the event loop, which automatically drops the connection
# (and incidentally calls the connection's unbind method).
module DumbHttpClient
  def post_init
    send_data &quot;GET / HTTP/1.1\r\nHost: _\r\n\r\n&quot;
    @data = &quot;&quot;
    @parsed = false
  end

  def receive_data data
    @data &lt;&lt; data
    if !@parsed and @data =~ /[\n][\r]*[\n]/m
      @parsed = true
      puts &quot;RECEIVED HTTP HEADER:&quot;
      $`.each {|line| puts &quot;&gt;&gt;&gt; #{line}&quot; }

      puts &quot;Now we'll terminate the loop, which will also close the connection&quot;
      EventMachine::stop_event_loop
    end
  end

  def unbind
    puts &quot;A connection has terminated&quot;
  end
end

EventMachine.run {
  EventMachine.connect &quot;www.bayshorenetworks.com&quot;, 80, DumbHttpClient
}
puts &quot;The event loop has ended&quot;</pre>

<p>@example Defining protocol handler as a class</p>

<pre>class MyProtocolHandler &lt; EventMachine::Connection
  def initialize *args
    super
    # whatever else you want to do here
  end

  # ...
end</pre>

<p>@param [String] server         Host to connect to @param [Integer] port    
Port to connect to @param [Module, Class] handler A module or class that
implements connection lifecycle callbacks</p>

<p>@see <a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a>
@see file:<a href="docs/GettingStarted_md.html">docs/GettingStarted.md</a>
<a href="EventMachine.html">EventMachine</a> tutorial</p>
            

            
            <div class="method-source-code" id="connect-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 630</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">connect</span> <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">blk</span>
  <span class="ruby-comment"># EventMachine::connect initiates a TCP connection to a remote</span>
  <span class="ruby-comment"># server and sets up event-handling for the connection.</span>
  <span class="ruby-comment"># It internally creates an object that should not be handled</span>
  <span class="ruby-comment"># by the caller. HOWEVER, it's often convenient to get the</span>
  <span class="ruby-comment"># object to set up interfacing to other objects in the system.</span>
  <span class="ruby-comment"># We return the newly-created anonymous-class object to the caller.</span>
  <span class="ruby-comment"># It's expected that a considerable amount of code will depend</span>
  <span class="ruby-comment"># on this behavior, so don't change it.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Ok, added support for a user-defined block, 13Apr06.</span>
  <span class="ruby-comment"># This leads us to an interesting choice because of the</span>
  <span class="ruby-comment"># presence of the post_init call, which happens in the</span>
  <span class="ruby-comment"># initialize method of the new object. We call the user's</span>
  <span class="ruby-comment"># block and pass the new object to it. This is a great</span>
  <span class="ruby-comment"># way to do protocol-specific initiation. It happens</span>
  <span class="ruby-comment"># AFTER post_init has been called on the object, which I</span>
  <span class="ruby-comment"># certainly hope is the right choice.</span>
  <span class="ruby-comment"># Don't change this lightly, because accepted connections</span>
  <span class="ruby-comment"># are different from connected ones and we don't want</span>
  <span class="ruby-comment"># to have them behave differently with respect to post_init</span>
  <span class="ruby-comment"># if at all possible.</span>

  <span class="ruby-identifier">bind_connect</span> <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">blk</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- connect-source -->
            
          </div>

          

          
        </div><!-- connect-method -->

      
        <div id="connect_server-method" class="method-detail ">
          <a name="method-c-connect_server"></a>

          
          <div class="method-heading">
            <span class="method-name">connect_server</span><span
              class="method-args">(host, port)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="connect_server-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">connect_server</span> <span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>
  <span class="ruby-identifier">bind_connect_server</span> <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- connect_server-source -->
            
          </div>

          

          
        </div><!-- connect_server-method -->

      
        <div id="connect_unix_domain-method" class="method-detail ">
          <a name="method-c-connect_unix_domain"></a>

          
          <div class="method-heading">
            <span class="method-name">connect_unix_domain</span><span
              class="method-args">(socketname, *args, &blk)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Make a connection to a Unix-domain socket. This method is simply an alias
for {.connect}, which can connect to both TCP and Unix-domain sockets. Make
sure that your process has sufficient permissions to open the socket it is
given.</p>

<p>@param [String] socketname Unix domain socket (local fully-qualified path)
you want to connect to.</p>

<p>@note UNIX sockets, as the name suggests, are not available on Microsoft
Windows.</p>
            

            
            <div class="method-source-code" id="connect_unix_domain-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 812</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">connect_unix_domain</span> <span class="ruby-identifier">socketname</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">blk</span>
  <span class="ruby-identifier">connect</span> <span class="ruby-identifier">socketname</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">blk</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- connect_unix_domain-source -->
            
          </div>

          

          
        </div><!-- connect_unix_domain-method -->

      
        <div id="connect_unix_server-method" class="method-detail ">
          <a name="method-c-connect_unix_server"></a>

          
          <div class="method-heading">
            <span class="method-name">connect_unix_server</span><span
              class="method-args">(chain)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="connect_unix_server-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">connect_unix_server</span> <span class="ruby-identifier">chain</span>
  <span class="ruby-constant">EvmaUNIXClient</span>.<span class="ruby-identifier">connect</span>(<span class="ruby-identifier">chain</span>).<span class="ruby-identifier">uuid</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- connect_unix_server-source -->
            
          </div>

          

          
        </div><!-- connect_unix_server-method -->

      
        <div id="connection_count-method" class="method-detail ">
          <a name="method-c-connection_count"></a>

          
          <div class="method-heading">
            <span class="method-name">connection_count</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the total number of connections (file descriptors) currently held
by the reactor. Note that a tick must pass after the ‘initiation’ of a
connection for this number to increment. It’s usually accurate, but don’t
rely on the exact precision of this number unless you really know <a
href="EventMachine.html">EM</a> internals.</p>

<p>@example</p>

<pre>EventMachine.run {
  EventMachine.connect(&quot;rubyeventmachine.com&quot;, 80)
  # count will be 0 in this case, because connection is not
  # established yet
  count = EventMachine.connection_count
}</pre>

<p>@example</p>

<pre>EventMachine.run {
  EventMachine.connect(&quot;rubyeventmachine.com&quot;, 80)

  EventMachine.next_tick {
    # In this example, count will be 1 since the connection has been established in
    # the next loop of the reactor.
    count = EventMachine.connection_count
  }
}</pre>

<p>@return [Integer] Number of connections currently held by the reactor.</p>
            

            
            <div class="method-source-code" id="connection_count-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 954</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">connection_count</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">get_connection_count</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- connection_count-source -->
            
          </div>

          

          
        </div><!-- connection_count-method -->

      
        <div id="defer-method" class="method-detail ">
          <a name="method-c-defer"></a>

          
          <div class="method-heading">
            <span class="method-name">defer</span><span
              class="method-args">(op = nil, callback = nil, errback = nil, &blk)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="EventMachine.html#method-c-defer">EventMachine.defer</a> is used
for integrating blocking operations into EventMachine's control flow. The
action of {.defer} is to take the block specified in the first parameter
(the "operation") and schedule it for asynchronous execution on an internal
thread pool maintained by <a href="EventMachine.html">EventMachine</a>.
When the operation completes, it will pass the result computed by the block
(if any) back to the <a href="EventMachine.html">EventMachine</a> reactor.
Then, <a href="EventMachine.html">EventMachine</a> calls the block
specified in the second parameter to {.defer} (the "callback"), as part of
its normal event handling loop. The result computed by the operation block
is passed as a parameter to the callback. You may omit the callback
parameter if you don't need to execute any code after the operation
completes. If the operation raises an unhandled exception, the exception
will be passed to the third parameter to {.defer} (the "errback"), as part
of its normal event handling loop. If no errback is provided, the exception
will be allowed to blow through to the main thread immediately.</p>

<p>## Caveats ##</p>

<p>Note carefully that the code in your deferred operation will be executed on
a separate thread from the main <a
href="EventMachine.html">EventMachine</a> processing and all other Ruby
threads that may exist in your program. Also, multiple deferred operations
may be running at once! Therefore, you are responsible for ensuring that
your operation code is threadsafe.</p>

<p>Don’t write a deferred operation that will block forever. If so, the
current implementation will not detect the problem, and the thread will
never be returned to the pool. <a href="EventMachine.html">EventMachine</a>
limits the number of threads in its pool, so if you do this enough times,
your subsequent deferred operations won’t get a chance to run.</p>

<p>The threads within the EventMachine’s thread pool have abort_on_exception
set to true. As a result, if an unhandled exception is raised by the
deferred operation and an errback is not provided, it will blow through to
the main thread immediately. If the main thread is within an indiscriminate
rescue block at that time, the exception could be handled improperly by the
main thread.</p>

<p>@example</p>

<pre>operation = proc {
  # perform a long-running operation here, such as a database query.
  &quot;result&quot; # as usual, the last expression evaluated in the block will be the return value.
}
callback = proc {|result|
  # do something with result here, such as send it back to a network client.
}
errback = proc {|error|
  # do something with error here, such as re-raising or logging.
}

EventMachine.defer(operation, callback, errback)</pre>

<p>@param [call] op       An operation you want to offload to <a
href="EventMachine.html">EventMachine</a> thread pool @param [call]
callback A callback that will be run on the event loop thread after
`operation` finishes. @param [call] errback  An errback that will be run on
the event loop thread after `operation` raises an exception.</p>

<p>@see <a
href="EventMachine.html#attribute-c-threadpool_size">EventMachine.threadpool_size</a></p>
            

            
            <div class="method-source-code" id="defer-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1042</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">defer</span> <span class="ruby-identifier">op</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">callback</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">errback</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">blk</span>
  <span class="ruby-comment"># OBSERVE that #next_tick hacks into this mechanism, so don't make any changes here</span>
  <span class="ruby-comment"># without syncing there.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Running with $VERBOSE set to true gives a warning unless all ivars are defined when</span>
  <span class="ruby-comment"># they appear in rvalues. But we DON'T ever want to initialize @threadqueue unless we</span>
  <span class="ruby-comment"># need it, because the Ruby threads are so heavyweight. We end up with this bizarre</span>
  <span class="ruby-comment"># way of initializing @threadqueue because EventMachine is a Module, not a Class, and</span>
  <span class="ruby-comment"># has no constructor.</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@threadpool</span>
    <span class="ruby-ivar">@threadpool</span> = []
    <span class="ruby-ivar">@threadqueue</span> = <span class="ruby-operator">::</span><span class="ruby-constant">Queue</span>.<span class="ruby-identifier">new</span>
    <span class="ruby-ivar">@resultqueue</span> = <span class="ruby-operator">::</span><span class="ruby-constant">Queue</span>.<span class="ruby-identifier">new</span>
    <span class="ruby-identifier">spawn_threadpool</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@threadqueue</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">op</span><span class="ruby-operator">||</span><span class="ruby-identifier">blk</span>,<span class="ruby-identifier">callback</span>,<span class="ruby-identifier">errback</span>]
<span class="ruby-keyword">end</span></pre>
            </div><!-- defer-source -->
            
          </div>

          

          
        </div><!-- defer-method -->

      
        <div id="defers_finished-3F-method" class="method-detail ">
          <a name="method-c-defers_finished-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">defers_finished?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns <tt>true</tt> if all deferred actions are done executing and their
callbacks have been fired.</p>
            

            
            <div class="method-source-code" id="defers_finished-3F-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1094</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">defers_finished?</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@threadpool</span> <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@all_threads_spawned</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@threadqueue</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">not</span> <span class="ruby-ivar">@threadqueue</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@resultqueue</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">not</span> <span class="ruby-ivar">@resultqueue</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@threadpool</span> <span class="ruby-keyword">and</span> <span class="ruby-ivar">@threadqueue</span>.<span class="ruby-identifier">num_waiting</span> <span class="ruby-operator">!=</span> <span class="ruby-ivar">@threadpool</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- defers_finished-3F-source -->
            
          </div>

          

          
        </div><!-- defers_finished-3F-method -->

      
        <div id="disable_proxy-method" class="method-detail ">
          <a name="method-c-disable_proxy"></a>

          
          <div class="method-heading">
            <span class="method-name">disable_proxy</span><span
              class="method-args">(from)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Takes just one argument, a {Connection} that has proxying enabled via {<a
href="EventMachine.html#method-c-enable_proxy">EventMachine.enable_proxy</a>}.
Calling this method will remove that functionality and your connection will
begin receiving data via {<a
href="EventMachine/Connection.html#method-i-receive_data">Connection#receive_data</a>}
again.</p>

<p>@param [EventMachine::Connection] from    Source of data that is being
proxied @see <a
href="EventMachine.html#method-c-enable_proxy">EventMachine.enable_proxy</a></p>
            

            
            <div class="method-source-code" id="disable_proxy-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1439</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">disable_proxy</span>(<span class="ruby-identifier">from</span>)
  <span class="ruby-constant">EM</span><span class="ruby-operator">::</span><span class="ruby-identifier">stop_proxy</span>(<span class="ruby-identifier">from</span>.<span class="ruby-identifier">signature</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- disable_proxy-source -->
            
          </div>

          

          
        </div><!-- disable_proxy-method -->

      
        <div id="enable_proxy-method" class="method-detail ">
          <a name="method-c-enable_proxy"></a>

          
          <div class="method-heading">
            <span class="method-name">enable_proxy</span><span
              class="method-args">(from, to, bufsize=0, length=0)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This method allows for direct writing of incoming data back out to another
descriptor, at the C++ level in the reactor. This is very efficient and
especially useful for proxies where high performance is required.
Propogating data from a server response all the way up to Ruby, and then
back down to the reactor to be sent back to the client, is often
unnecessary and incurs a significant performance decrease.</p>

<p>The two arguments are instance of {EventMachine::Connection} subclasses,
‘from’ and ‘to’. ‘from’ is the connection whose inbound data you want
relayed back out. ‘to’ is the connection to write it to.</p>

<p>Once you call this method, the ‘from’ connection will no longer get
receive_data callbacks from the reactor, except in the case that ‘to’
connection has already closed when attempting to write to it. You can see
in the example, that proxy_target_unbound will be called when this occurs.
After that, further incoming data will be passed into receive_data as
normal.</p>

<p>Note also that this feature supports different types of descriptors: TCP,
UDP, and pipes. You can relay data from one kind to another, for example,
feed a pipe from a UDP stream.</p>

<p>@example</p>

<pre>module ProxyConnection
  def initialize(client, request)
    @client, @request = client, request
  end

  def post_init
    EM::enable_proxy(self, @client)
  end

  def connection_completed
    send_data @request
  end

  def proxy_target_unbound
    close_connection
  end

  def unbind
    @client.close_connection_after_writing
  end
end

module ProxyServer
  def receive_data(data)
    (@buf ||= &quot;&quot;) &lt;&lt; data
    if @buf =~ /\r\n\r\n/ # all http headers received
      EventMachine.connect(&quot;10.0.0.15&quot;, 80, ProxyConnection, self, data)
    end
  end
end

EventMachine.run {
  EventMachine.start_server(&quot;127.0.0.1&quot;, 8080, ProxyServer)
}</pre>

<p>@param [EventMachine::Connection] from    Source of data to be
proxies/streamed. @param [EventMachine::Connection] to      Destination of
data to be proxies/streamed. @param [Integer]                  bufsize
Buffer size to use @param [Integer]                  length  Maximum number
of bytes to proxy.</p>

<p>@see <a
href="EventMachine.html#method-c-disable_proxy">EventMachine.disable_proxy</a></p>
            

            
            <div class="method-source-code" id="enable_proxy-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1429</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">enable_proxy</span>(<span class="ruby-identifier">from</span>, <span class="ruby-identifier">to</span>, <span class="ruby-identifier">bufsize</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">length</span>=<span class="ruby-value">0</span>)
  <span class="ruby-constant">EM</span><span class="ruby-operator">::</span><span class="ruby-identifier">start_proxy</span>(<span class="ruby-identifier">from</span>.<span class="ruby-identifier">signature</span>, <span class="ruby-identifier">to</span>.<span class="ruby-identifier">signature</span>, <span class="ruby-identifier">bufsize</span>, <span class="ruby-identifier">length</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- enable_proxy-source -->
            
          </div>

          

          
        </div><!-- enable_proxy-method -->

      
        <div id="epoll-method" class="method-detail ">
          <a name="method-c-epoll"></a>

          
          <div class="method-heading">
            <span class="method-name">epoll</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This method is a harmless no-op in the pure-Ruby implementation. This is
intended to ensure that user code behaves properly across different <a
href="EventMachine.html">EM</a> implementations. @private</p>
            

            
            <div class="method-source-code" id="epoll-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">epoll</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- epoll-source -->
            
          </div>

          

          
        </div><!-- epoll-method -->

      
        <div id="error_handler-method" class="method-detail ">
          <a name="method-c-error_handler"></a>

          
          <div class="method-heading">
            <span class="method-name">error_handler</span><span
              class="method-args">(cb = nil, &blk)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Catch-all for errors raised during event loop callbacks.</p>

<p>@example</p>

<pre>EventMachine.error_handler{ |e|
  puts &quot;Error raised during event loop: #{e.message}&quot;
}</pre>

<p>@param [call] cb Global catch-all errback</p>
            

            
            <div class="method-source-code" id="error_handler-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1362</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">error_handler</span> <span class="ruby-identifier">cb</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">blk</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">cb</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">blk</span>
    <span class="ruby-ivar">@error_handler</span> = <span class="ruby-identifier">cb</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">blk</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">instance_variable_defined?</span> <span class="ruby-value">:@error_handler</span>
    <span class="ruby-identifier">remove_instance_variable</span> <span class="ruby-value">:@error_handler</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- error_handler-source -->
            
          </div>

          

          
        </div><!-- error_handler-method -->

      
        <div id="event_callback-method" class="method-detail ">
          <a name="method-c-event_callback"></a>

          
          <div class="method-heading">
            <span class="method-name">event_callback</span><span
              class="method-args">(conn_binding, opcode, data)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="event_callback-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1462</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">event_callback</span> <span class="ruby-identifier">conn_binding</span>, <span class="ruby-identifier">opcode</span>, <span class="ruby-identifier">data</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Changed 27Dec07: Eliminated the hookable error handling.</span>
  <span class="ruby-comment"># No one was using it, and it degraded performance significantly.</span>
  <span class="ruby-comment"># It's in original_event_callback, which is dead code.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Changed 25Jul08: Added a partial solution to the problem of exceptions</span>
  <span class="ruby-comment"># raised in user-written event-handlers. If such exceptions are not caught,</span>
  <span class="ruby-comment"># we must cause the reactor to stop, and then re-raise the exception.</span>
  <span class="ruby-comment"># Otherwise, the reactor doesn't stop and it's left on the call stack.</span>
  <span class="ruby-comment"># This is partial because we only added it to #unbind, where it's critical</span>
  <span class="ruby-comment"># (to keep unbind handlers from being re-entered when a stopping reactor</span>
  <span class="ruby-comment"># runs down open connections). It should go on the other calls to user</span>
  <span class="ruby-comment"># code, but the performance impact may be too large.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opcode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">ConnectionUnbound</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@conns</span>.<span class="ruby-identifier">delete</span>( <span class="ruby-identifier">conn_binding</span> )
      <span class="ruby-keyword">begin</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">original_method</span>(<span class="ruby-value">:unbind</span>).<span class="ruby-identifier">arity</span> <span class="ruby-operator">!=</span> <span class="ruby-value">0</span>
          <span class="ruby-identifier">c</span>.<span class="ruby-identifier">unbind</span>(<span class="ruby-identifier">data</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-constant">ERRNOS</span>[<span class="ruby-identifier">data</span>])
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">c</span>.<span class="ruby-identifier">unbind</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-comment"># If this is an attached (but not watched) connection, close the underlying io object.</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_defined?</span>(<span class="ruby-value">:@io</span>) <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-value">:@watch_mode</span>)
          <span class="ruby-identifier">io</span> = <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-value">:@io</span>)
          <span class="ruby-keyword">begin</span>
            <span class="ruby-identifier">io</span>.<span class="ruby-identifier">close</span>
          <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EBADF</span>, <span class="ruby-constant">IOError</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Exception</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">stopping?</span>
          <span class="ruby-ivar">@wrapped_exception</span> = <span class="ruby-identifier">$!</span>
          <span class="ruby-identifier">stop</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">raise</span> <span class="ruby-identifier">e</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@acceptors</span>.<span class="ruby-identifier">delete</span>( <span class="ruby-identifier">conn_binding</span> )
      <span class="ruby-comment"># no-op</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">$!</span> <span class="ruby-comment"># Bubble user generated errors.</span>
        <span class="ruby-ivar">@wrapped_exception</span> = <span class="ruby-identifier">$!</span>
        <span class="ruby-constant">EM</span>.<span class="ruby-identifier">stop</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">raise</span> <span class="ruby-constant">ConnectionNotBound</span>, <span class="ruby-node">&quot;received ConnectionUnbound for an unknown signature: #{conn_binding}&quot;</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">opcode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">ConnectionAccepted</span>
    <span class="ruby-identifier">accep</span>,<span class="ruby-identifier">args</span>,<span class="ruby-identifier">blk</span> = <span class="ruby-ivar">@acceptors</span>[<span class="ruby-identifier">conn_binding</span>]
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">NoHandlerForAcceptedConnection</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">accep</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-identifier">accep</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">data</span>, *<span class="ruby-identifier">args</span>
    <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">data</span>] = <span class="ruby-identifier">c</span>
    <span class="ruby-identifier">blk</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">blk</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">c</span>)
    <span class="ruby-identifier">c</span> <span class="ruby-comment"># (needed?)</span>
    <span class="ruby-comment">##</span>
    <span class="ruby-comment"># The remaining code is a fallback for the pure ruby and java reactors.</span>
    <span class="ruby-comment"># In the C++ reactor, these events are handled in the C event_callback() in rubymain.cpp</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">opcode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">ConnectionCompleted</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">conn_binding</span>] <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-constant">ConnectionNotBound</span>, <span class="ruby-node">&quot;received ConnectionCompleted for unknown signature: #{conn_binding}&quot;</span>
    <span class="ruby-identifier">c</span>.<span class="ruby-identifier">connection_completed</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">opcode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">SslHandshakeCompleted</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">conn_binding</span>] <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-constant">ConnectionNotBound</span>, <span class="ruby-node">&quot;received SslHandshakeCompleted for unknown signature: #{conn_binding}&quot;</span>
    <span class="ruby-identifier">c</span>.<span class="ruby-identifier">ssl_handshake_completed</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">opcode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">SslVerify</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">conn_binding</span>] <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-constant">ConnectionNotBound</span>, <span class="ruby-node">&quot;received SslVerify for unknown signature: #{conn_binding}&quot;</span>
    <span class="ruby-identifier">c</span>.<span class="ruby-identifier">close_connection</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">ssl_verify_peer</span>(<span class="ruby-identifier">data</span>) <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">opcode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">TimerFired</span>
    <span class="ruby-identifier">t</span> = <span class="ruby-ivar">@timers</span>.<span class="ruby-identifier">delete</span>( <span class="ruby-identifier">data</span> )
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">t</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span> <span class="ruby-comment"># timer cancelled</span>
    <span class="ruby-identifier">t</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-constant">UnknownTimerFired</span>, <span class="ruby-node">&quot;timer data: #{data}&quot;</span>
    <span class="ruby-identifier">t</span>.<span class="ruby-identifier">call</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">opcode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">ConnectionData</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">conn_binding</span>] <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-constant">ConnectionNotBound</span>, <span class="ruby-node">&quot;received data #{data} for unknown signature: #{conn_binding}&quot;</span>
    <span class="ruby-identifier">c</span>.<span class="ruby-identifier">receive_data</span> <span class="ruby-identifier">data</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">opcode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LoopbreakSignalled</span>
    <span class="ruby-identifier">run_deferred_callbacks</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">opcode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">ConnectionNotifyReadable</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">conn_binding</span>] <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-constant">ConnectionNotBound</span>
    <span class="ruby-identifier">c</span>.<span class="ruby-identifier">notify_readable</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">opcode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">ConnectionNotifyWritable</span>
    <span class="ruby-identifier">c</span> = <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">conn_binding</span>] <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-constant">ConnectionNotBound</span>
    <span class="ruby-identifier">c</span>.<span class="ruby-identifier">notify_writable</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- event_callback-source -->
            
          </div>

          

          
        </div><!-- event_callback-method -->

      
        <div id="fork_reactor-method" class="method-detail ">
          <a name="method-c-fork_reactor"></a>

          
          <div class="method-heading">
            <span class="method-name">fork_reactor</span><span
              class="method-args">(&block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Forks a new process, properly stops the reactor and then calls {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>} inside of it
again, passing your block.</p>
            

            
            <div class="method-source-code" id="fork_reactor-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 242</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">fork_reactor</span> &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-comment"># This implementation is subject to change, especially if we clean up the relationship</span>
  <span class="ruby-comment"># of EM#run to @reactor_running.</span>
  <span class="ruby-comment"># Original patch by Aman Gupta.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-constant">Kernel</span>.<span class="ruby-identifier">fork</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">reactor_running?</span>
      <span class="ruby-identifier">stop_event_loop</span>
      <span class="ruby-identifier">release_machine</span>
      <span class="ruby-identifier">cleanup_machine</span>
      <span class="ruby-ivar">@reactor_running</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-ivar">@reactor_thread</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">run</span> <span class="ruby-identifier">block</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- fork_reactor-source -->
            
          </div>

          

          
        </div><!-- fork_reactor-method -->

      
        <div id="get_cipher_bits-method" class="method-detail ">
          <a name="method-c-get_cipher_bits"></a>

          
          <div class="method-heading">
            <span class="method-name">get_cipher_bits</span><span
              class="method-args">(signature)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="get_cipher_bits-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 353</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_cipher_bits</span> <span class="ruby-identifier">signature</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>(<span class="ruby-identifier">signature</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown get_cipher_bits target&quot;</span>
  <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:cipher</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">cipher</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_cipher_bits-source -->
            
          </div>

          

          
        </div><!-- get_cipher_bits-method -->

      
        <div id="get_cipher_name-method" class="method-detail ">
          <a name="method-c-get_cipher_name"></a>

          
          <div class="method-heading">
            <span class="method-name">get_cipher_name</span><span
              class="method-args">(signature)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="get_cipher_name-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 343</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_cipher_name</span> <span class="ruby-identifier">signature</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>(<span class="ruby-identifier">signature</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown get_cipher_name target&quot;</span>
  <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:cipher</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">cipher</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_cipher_name-source -->
            
          </div>

          

          
        </div><!-- get_cipher_name-method -->

      
        <div id="get_cipher_protocol-method" class="method-detail ">
          <a name="method-c-get_cipher_protocol"></a>

          
          <div class="method-heading">
            <span class="method-name">get_cipher_protocol</span><span
              class="method-args">(signature)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="get_cipher_protocol-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 348</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_cipher_protocol</span> <span class="ruby-identifier">signature</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>(<span class="ruby-identifier">signature</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown get_cipher_protocol target&quot;</span>
  <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:cipher</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">cipher</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_cipher_protocol-source -->
            
          </div>

          

          
        </div><!-- get_cipher_protocol-method -->

      
        <div id="get_max_timers-method" class="method-detail ">
          <a name="method-c-get_max_timers"></a>

          
          <div class="method-heading">
            <span class="method-name">get_max_timers</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Gets the current maximum number of allowed timers</p>

<p>@return [Integer] Maximum number of timers that may be outstanding at any
given time</p>
            

            
            <div class="method-source-code" id="get_max_timers-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 923</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">get_max_timers</span>
  <span class="ruby-identifier">get_max_timer_count</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_max_timers-source -->
            
          </div>

          

          
        </div><!-- get_max_timers-method -->

      
        <div id="get_outbound_data_size-method" class="method-detail ">
          <a name="method-c-get_outbound_data_size"></a>

          
          <div class="method-heading">
            <span class="method-name">get_outbound_data_size</span><span
              class="method-args">(sig)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="get_outbound_data_size-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 406</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_outbound_data_size</span> <span class="ruby-identifier">sig</span>
  <span class="ruby-identifier">r</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>( <span class="ruby-identifier">sig</span> ) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown get_outbound_data_size target&quot;</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get_outbound_data_size</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_outbound_data_size-source -->
            
          </div>

          

          
        </div><!-- get_outbound_data_size-method -->

      
        <div id="get_peer_cert-method" class="method-detail ">
          <a name="method-c-get_peer_cert"></a>

          
          <div class="method-heading">
            <span class="method-name">get_peer_cert</span><span
              class="method-args">(signature)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="get_peer_cert-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 334</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_peer_cert</span> <span class="ruby-identifier">signature</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>(<span class="ruby-identifier">signature</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown get_peer_cert target&quot;</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:peer_cert</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">peer_cert</span>
    <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">peer_cert</span>.<span class="ruby-identifier">to_pem</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_peer_cert-source -->
            
          </div>

          

          
        </div><!-- get_peer_cert-method -->

      
        <div id="get_peername-method" class="method-detail ">
          <a name="method-c-get_peername"></a>

          
          <div class="method-heading">
            <span class="method-name">get_peername</span><span
              class="method-args">(sig)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="get_peername-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_peername</span> <span class="ruby-identifier">sig</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>( <span class="ruby-identifier">sig</span> ) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown get_peername target&quot;</span>
  <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">get_peername</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_peername-source -->
            
          </div>

          

          
        </div><!-- get_peername-method -->

      
        <div id="get_sni_hostname-method" class="method-detail ">
          <a name="method-c-get_sni_hostname"></a>

          
          <div class="method-heading">
            <span class="method-name">get_sni_hostname</span><span
              class="method-args">(signature)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="get_sni_hostname-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 358</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_sni_hostname</span> <span class="ruby-identifier">signature</span>
  <span class="ruby-ivar">@tls_parms</span> <span class="ruby-operator">||=</span> {}
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@tls_parms</span>[<span class="ruby-identifier">signature</span>]
    <span class="ruby-ivar">@tls_parms</span>[<span class="ruby-identifier">signature</span>][<span class="ruby-value">:server_name</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_sni_hostname-source -->
            
          </div>

          

          
        </div><!-- get_sni_hostname-method -->

      
        <div id="get_sock_opt-method" class="method-detail ">
          <a name="method-c-get_sock_opt"></a>

          
          <div class="method-heading">
            <span class="method-name">get_sock_opt</span><span
              class="method-args">(signature, level, optname)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="get_sock_opt-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 381</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_sock_opt</span> <span class="ruby-identifier">signature</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">optname</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>( <span class="ruby-identifier">signature</span> ) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown get_sock_opt target&quot;</span>
  <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">getsockopt</span> <span class="ruby-identifier">level</span>, <span class="ruby-identifier">optname</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_sock_opt-source -->
            
          </div>

          

          
        </div><!-- get_sock_opt-method -->

      
        <div id="heartbeat_interval-method" class="method-detail ">
          <a name="method-c-heartbeat_interval"></a>

          
          <div class="method-heading">
            <span class="method-name">heartbeat_interval</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Retrieve the heartbeat interval. This is how often <a
href="EventMachine.html">EventMachine</a> will check for dead connections
that have had an inactivity timeout set via {<a
href="EventMachine/Connection.html#method-i-set_comm_inactivity_timeout">Connection#set_comm_inactivity_timeout</a>}.
Default is 2 seconds.</p>

<p>@return [Integer] Heartbeat interval, in seconds</p>
            

            
            <div class="method-source-code" id="heartbeat_interval-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1448</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">heartbeat_interval</span>
  <span class="ruby-constant">EM</span><span class="ruby-operator">::</span><span class="ruby-identifier">get_heartbeat_interval</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- heartbeat_interval-source -->
            
          </div>

          

          
        </div><!-- heartbeat_interval-method -->

      
        <div id="heartbeat_interval-3D-method" class="method-detail ">
          <a name="method-c-heartbeat_interval-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">heartbeat_interval=</span><span
              class="method-args">(time)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Set the heartbeat interval. This is how often <a
href="EventMachine.html">EventMachine</a> will check for dead connections
that have had an inactivity timeout set via {<a
href="EventMachine/Connection.html#method-i-set_comm_inactivity_timeout">Connection#set_comm_inactivity_timeout</a>}.
Takes a Numeric number of seconds. Default is 2.</p>

<p>@param [Integer] time Heartbeat interval, in seconds</p>
            

            
            <div class="method-source-code" id="heartbeat_interval-3D-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1457</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">heartbeat_interval=</span>(<span class="ruby-identifier">time</span>)
  <span class="ruby-constant">EM</span><span class="ruby-operator">::</span><span class="ruby-identifier">set_heartbeat_interval</span> <span class="ruby-identifier">time</span>.<span class="ruby-identifier">to_f</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- heartbeat_interval-3D-source -->
            
          </div>

          

          
        </div><!-- heartbeat_interval-3D-method -->

      
        <div id="initialize_event_machine-method" class="method-detail ">
          <a name="method-c-initialize_event_machine"></a>

          
          <div class="method-heading">
            <span class="method-name">initialize_event_machine</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="initialize_event_machine-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize_event_machine</span>
  <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">initialize_for_run</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- initialize_event_machine-source -->
            
          </div>

          

          
        </div><!-- initialize_event_machine-method -->

      
        <div id="klass_from_handler-method" class="method-detail ">
          <a name="method-c-klass_from_handler"></a>

          
          <div class="method-heading">
            <span class="method-name">klass_from_handler</span><span
              class="method-args">(klass = Connection, handler = nil, *args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="klass_from_handler-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1563</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-identifier">klass</span> = <span class="ruby-constant">Connection</span>, <span class="ruby-identifier">handler</span> = <span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">klass</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">handler</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">handler</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Class</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;must provide module or subclass of #{klass.name}&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">klass</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">handler</span>
    <span class="ruby-identifier">handler</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">handler</span>
    <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-identifier">handler</span><span class="ruby-operator">::</span><span class="ruby-constant">EM_CONNECTION_CLASS</span>)
      <span class="ruby-identifier">handler</span><span class="ruby-operator">::</span><span class="ruby-constant">EM_CONNECTION_CLASS</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">handler</span><span class="ruby-operator">::</span><span class="ruby-identifier">const_set</span>(<span class="ruby-value">:EM_CONNECTION_CLASS</span>, <span class="ruby-constant">Class</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">klass</span>) {<span class="ruby-identifier">include</span> <span class="ruby-identifier">handler</span>})
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">klass</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">arity</span> = <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">instance_method</span>(<span class="ruby-value">:initialize</span>).<span class="ruby-identifier">arity</span>
  <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">arity</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">arity</span> <span class="ruby-operator">:</span> <span class="ruby-operator">-</span>(<span class="ruby-identifier">arity</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">arity</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">expected</span>) <span class="ruby-keyword">or</span> (<span class="ruby-identifier">arity</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">expected</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;wrong number of arguments for #{klass}#initialize (#{args.size} for #{expected})&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">klass</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- klass_from_handler-source -->
            
          </div>

          

          
        </div><!-- klass_from_handler-method -->

      
        <div id="library_type-method" class="method-detail ">
          <a name="method-c-library_type"></a>

          
          <div class="method-heading">
            <span class="method-name">library_type</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This is mostly useful for automated tests. Return a distinctive symbol so
the caller knows whether he’s dealing with an extension or with a pure-Ruby
library. @private</p>
            

            
            <div class="method-source-code" id="library_type-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">library_type</span>
  <span class="ruby-value">:pure_ruby</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- library_type-source -->
            
          </div>

          

          
        </div><!-- library_type-method -->

      
        <div id="next_tick-method" class="method-detail ">
          <a name="method-c-next_tick"></a>

          
          <div class="method-heading">
            <span class="method-name">next_tick</span><span
              class="method-args">(pr=nil, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Schedules a proc for execution immediately after the next “turn” through
the reactor core. An advanced technique, this can be useful for improving
memory management and/or application responsiveness, especially when
scheduling large amounts of data for writing to a network connection.</p>

<p>This method takes either a single argument (which must be a callable
object) or a block.</p>

<p>@param [call] pr A callable object to run</p>
            

            
            <div class="method-source-code" id="next_tick-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1120</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_tick</span> <span class="ruby-identifier">pr</span>=<span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-comment"># This works by adding to the @resultqueue that's used for #defer.</span>
  <span class="ruby-comment"># The general idea is that next_tick is used when we want to give the reactor a chance</span>
  <span class="ruby-comment"># to let other operations run, either to balance the load out more evenly, or to let</span>
  <span class="ruby-comment"># outbound network buffers drain, or both. So we probably do NOT want to block, and</span>
  <span class="ruby-comment"># we probably do NOT want to be spinning any threads. A program that uses next_tick</span>
  <span class="ruby-comment"># but not #defer shouldn't suffer the penalty of having Ruby threads running. They're</span>
  <span class="ruby-comment"># extremely expensive even if they're just sleeping.</span>

  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;no proc or block given&quot;</span> <span class="ruby-keyword">unless</span> ((<span class="ruby-identifier">pr</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">pr</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:call</span>)) <span class="ruby-keyword">or</span> <span class="ruby-identifier">block</span>)
  <span class="ruby-ivar">@next_tick_mutex</span>.<span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span>
    <span class="ruby-ivar">@next_tick_queue</span> <span class="ruby-operator">&lt;&lt;</span> ( <span class="ruby-identifier">pr</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">block</span> )
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">signal_loopbreak</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">reactor_running?</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- next_tick-source -->
            
          </div>

          

          
        </div><!-- next_tick-method -->

      
        <div id="open_datagram_socket-method" class="method-detail ">
          <a name="method-c-open_datagram_socket"></a>

          
          <div class="method-heading">
            <span class="method-name">open_datagram_socket</span><span
              class="method-args">(address, port, handler=nil, *args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Used for UDP-based protocols. Its usage is similar to that of {<a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a>}.</p>

<p>This method will create a new UDP (datagram) socket and bind it to the
address and port that you specify. The normal callbacks (see {<a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a>})
will be called as events of interest occur on the newly-created socket, but
there are some differences in how they behave.</p>

<p>{<a
href="EventMachine/Connection.html#method-i-receive_data">Connection#receive_data</a>}
will be called when a datagram packet is received on the socket, but unlike
TCP sockets, the message boundaries of the received data will be respected.
In other words, if the remote peer sent you a datagram of a particular
size, you may rely on {<a
href="EventMachine/Connection.html#method-i-receive_data">Connection#receive_data</a>}
to give you the exact data in the packet, with the original data length.
Also observe that <a
href="EventMachine/Connection.html#method-i-receive_data">Connection#receive_data</a>
may be called with a <b>zero-length</b> data payload, since empty datagrams
are permitted in UDP.</p>

<p>{<a
href="EventMachine/Connection.html#method-i-send_data">Connection#send_data</a>}
is available with UDP packets as with TCP, but there is an important
difference. Because UDP communications are <b>connectionless</b>, there is
no implicit recipient for the packets you send. Ordinarily you must specify
the recipient for each packet you send. However, <a
href="EventMachine.html">EventMachine</a> provides for the typical pattern
of receiving a UDP datagram from a remote peer, performing some operation,
and then sending one or more packets in response to the same remote peer.
To support this model easily, just use {<a
href="EventMachine/Connection.html#method-i-send_data">Connection#send_data</a>}
in the code that you supply for {<a
href="EventMachine/Connection.html#method-i-receive_data">Connection#receive_data</a>}.</p>

<p><a href="EventMachine.html">EventMachine</a> will provide an implicit
return address for any messages sent to {<a
href="EventMachine/Connection.html#method-i-send_data">Connection#send_data</a>}
within the context of a {<a
href="EventMachine/Connection.html#method-i-receive_data">Connection#receive_data</a>}
callback, and your response will automatically go to the correct remote
peer.</p>

<p>Observe that the port number that you supply to {<a
href="EventMachine.html#method-c-open_datagram_socket">EventMachine.open_datagram_socket</a>}
may be zero. In this case, <a href="EventMachine.html">EventMachine</a>
will create a UDP socket that is bound to an [ephemeral port](<a
href="http://en.wikipedia.org/wiki/Ephemeral_port">en.wikipedia.org/wiki/Ephemeral_port</a>).
This is not appropriate for servers that must publish a well-known port to
which remote peers may send datagrams. But it can be useful for clients
that send datagrams to other servers. If you do this, you will receive any
responses from the remote servers through the normal {<a
href="EventMachine/Connection.html#method-i-receive_data">Connection#receive_data</a>}
callback. Observe that you will probably have issues with firewalls
blocking the ephemeral port numbers, so this technique is most appropriate
for LANs.</p>

<p>If you wish to send datagrams to arbitrary remote peers (not necessarily
ones that have sent data to which you are responding), then see {<a
href="EventMachine/Connection.html#method-i-send_datagram">Connection#send_datagram</a>}.</p>

<p>DO NOT call <a href="EventMachine.html#method-c-send_data">send_data</a>
from a datagram socket outside of a {<a
href="EventMachine/Connection.html#method-i-receive_data">Connection#receive_data</a>}
method. Use {<a
href="EventMachine/Connection.html#method-i-send_datagram">Connection#send_datagram</a>}.
If you do use {<a
href="EventMachine/Connection.html#method-i-send_data">Connection#send_data</a>}
outside of a {<a
href="EventMachine/Connection.html#method-i-receive_data">Connection#receive_data</a>}
method, you’ll get a confusing error because there is no “peer,” as
send_data requires (inside of {<a
href="EventMachine/Connection.html#method-i-receive_data">EventMachine::Connection#receive_data</a>},
{<a
href="EventMachine/Connection.html#method-i-send_data">EventMachine::Connection#send_data</a>}
“fakes” the peer as described above).</p>

<p>@param [String]         address IP address @param [String]         port   
Port @param [Class, Module]  handler A class or a module that implements
connection lifecycle callbacks.</p>
            

            
            <div class="method-source-code" id="open_datagram_socket-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 871</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">open_datagram_socket</span> <span class="ruby-identifier">address</span>, <span class="ruby-identifier">port</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-comment"># Replaced the implementation on 01Oct06. Thanks to Tobias Gustafsson for pointing</span>
  <span class="ruby-comment"># out that this originally did not take a class but only a module.</span>


  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-constant">Connection</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">s</span> = <span class="ruby-identifier">open_udp_socket</span> <span class="ruby-identifier">address</span>, <span class="ruby-identifier">port</span>.<span class="ruby-identifier">to_i</span>
  <span class="ruby-identifier">c</span> = <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">s</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">block_given?</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">c</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- open_datagram_socket-source -->
            
          </div>

          

          
        </div><!-- open_datagram_socket-method -->

      
        <div id="open_keyboard-method" class="method-detail ">
          <a name="method-c-open_keyboard"></a>

          
          <div class="method-heading">
            <span class="method-name">open_keyboard</span><span
              class="method-args">(handler=nil, *args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>(Experimental)</p>

<p>@private</p>
            

            
            <div class="method-source-code" id="open_keyboard-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1234</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">open_keyboard</span> <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-constant">Connection</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>)

  <span class="ruby-identifier">s</span> = <span class="ruby-identifier">read_keyboard</span>
  <span class="ruby-identifier">c</span> = <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">s</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">block_given?</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">c</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- open_keyboard-source -->
            
          </div>

          

          
        </div><!-- open_keyboard-method -->

      
        <div id="open_udp_socket-method" class="method-detail ">
          <a name="method-c-open_udp_socket"></a>

          
          <div class="method-heading">
            <span class="method-name">open_udp_socket</span><span
              class="method-args">(host, port)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="open_udp_socket-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">open_udp_socket</span> <span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>
  <span class="ruby-constant">EvmaUDPSocket</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>).<span class="ruby-identifier">uuid</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- open_udp_socket-source -->
            
          </div>

          

          
        </div><!-- open_udp_socket-method -->

      
        <div id="popen-method" class="method-detail ">
          <a name="method-c-popen"></a>

          
          <div class="method-heading">
            <span class="method-name">popen</span><span
              class="method-args">(cmd, handler=nil, *args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Runs an external process.</p>

<p>@example</p>

<pre>module RubyCounter
  def post_init
    # count up to 5
    send_data &quot;5\n&quot;
  end
  def receive_data data
    puts &quot;ruby sent me: #{data}&quot;
  end
  def unbind
    puts &quot;ruby died with exit status: #{get_status.exitstatus}&quot;
  end
end

EventMachine.run {
  EventMachine.popen(&quot;ruby -e' $stdout.sync = true; gets.to_i.times{ |i| puts i+1; sleep 1 } '&quot;, RubyCounter)
}</pre>

<p>@note This method is not supported on Microsoft Windows @see <a
href="EventMachine/DeferrableChildProcess.html">EventMachine::DeferrableChildProcess</a>
@see <a href="EventMachine.html#method-c-system">EventMachine.system</a></p>
            

            
            <div class="method-source-code" id="popen-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1197</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">popen</span> <span class="ruby-identifier">cmd</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-comment"># At this moment, it's only available on Unix.</span>
  <span class="ruby-comment"># Perhaps misnamed since the underlying function uses socketpair and is full-duplex.</span>

  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-constant">Connection</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">w</span> = <span class="ruby-keyword">case</span> <span class="ruby-identifier">cmd</span>
      <span class="ruby-keyword">when</span> <span class="ruby-constant">Array</span>
        <span class="ruby-identifier">cmd</span>
      <span class="ruby-keyword">when</span> <span class="ruby-constant">String</span>
        <span class="ruby-constant">Shellwords</span><span class="ruby-operator">::</span><span class="ruby-identifier">shellwords</span>( <span class="ruby-identifier">cmd</span> )
      <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">w</span>.<span class="ruby-identifier">unshift</span>( <span class="ruby-identifier">w</span>.<span class="ruby-identifier">first</span> ) <span class="ruby-keyword">if</span> <span class="ruby-identifier">w</span>.<span class="ruby-identifier">first</span>
  <span class="ruby-identifier">s</span> = <span class="ruby-identifier">invoke_popen</span>( <span class="ruby-identifier">w</span> )
  <span class="ruby-identifier">c</span> = <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">s</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">c</span>
  <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">c</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">c</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- popen-source -->
            
          </div>

          

          
        </div><!-- popen-method -->

      
        <div id="reactor_running-3F-method" class="method-detail ">
          <a name="method-c-reactor_running-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">reactor_running?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Tells you whether the <a href="EventMachine.html">EventMachine</a> reactor
loop is currently running.</p>

<p>Useful when writing libraries that want to run event-driven code, but may
be running in programs that are already event-driven. In such cases, if {<a
href="EventMachine.html#method-c-reactor_running-3F">EventMachine.reactor_running?</a>}
returns false, your code can invoke {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>} and run your
application code inside the block passed to that method. If this method
returns true, just execute your event-aware code.</p>

<p>@return [Boolean] true if the <a href="EventMachine.html">EventMachine</a>
reactor loop is currently running</p>
            

            
            <div class="method-source-code" id="reactor_running-3F-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1226</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reactor_running?</span>
  <span class="ruby-ivar">@reactor_running</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Process</span>.<span class="ruby-identifier">pid</span> <span class="ruby-operator">==</span> <span class="ruby-ivar">@reactor_pid</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- reactor_running-3F-source -->
            
          </div>

          

          
        </div><!-- reactor_running-3F-method -->

      
        <div id="reactor_thread-3F-method" class="method-detail ">
          <a name="method-c-reactor_thread-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">reactor_thread?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@return [Boolean] true if the calling thread is the same thread as the
reactor.</p>
            

            
            <div class="method-source-code" id="reactor_thread-3F-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 226</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reactor_thread?</span>
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span> <span class="ruby-operator">==</span> <span class="ruby-ivar">@reactor_thread</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- reactor_thread-3F-source -->
            
          </div>

          

          
        </div><!-- reactor_thread-3F-method -->

      
        <div id="read_keyboard-method" class="method-detail ">
          <a name="method-c-read_keyboard"></a>

          
          <div class="method-heading">
            <span class="method-name">read_keyboard</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="read_keyboard-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 412</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">read_keyboard</span>
  <span class="ruby-constant">EvmaKeyboard</span>.<span class="ruby-identifier">open</span>.<span class="ruby-identifier">uuid</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- read_keyboard-source -->
            
          </div>

          

          
        </div><!-- read_keyboard-method -->

      
        <div id="reconnect-method" class="method-detail ">
          <a name="method-c-reconnect"></a>

          
          <div class="method-heading">
            <span class="method-name">reconnect</span><span
              class="method-args">(server, port, handler)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Connect to a given host/port and re-use the provided
{EventMachine::Connection} instance. Consider also {<a
href="EventMachine/Connection.html#method-i-reconnect">EventMachine::Connection#reconnect</a>}.</p>

<p>@see <a
href="EventMachine/Connection.html#method-i-reconnect">EventMachine::Connection#reconnect</a></p>
            

            
            <div class="method-source-code" id="reconnect-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 780</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reconnect</span> <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>, <span class="ruby-identifier">handler</span>
  <span class="ruby-comment"># Observe, the test for already-connected FAILS if we call a reconnect inside post_init,</span>
  <span class="ruby-comment"># because we haven't set up the connection in @conns by that point.</span>
  <span class="ruby-comment"># RESIST THE TEMPTATION to &quot;fix&quot; this problem by redefining the behavior of post_init.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Changed 22Nov06: if called on an already-connected handler, just return the</span>
  <span class="ruby-comment"># handler and do nothing more. Originally this condition raised an exception.</span>
  <span class="ruby-comment"># We may want to change it yet again and call the block, if any.</span>

  <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;invalid handler&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">handler</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:connection_completed</span>)
  <span class="ruby-comment">#raise &quot;still connected&quot; if @conns.has_key?(handler.signature)</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">handler</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@conns</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">handler</span>.<span class="ruby-identifier">signature</span>)

  <span class="ruby-identifier">s</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">port</span>
        <span class="ruby-identifier">connect_server</span> <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">connect_unix_server</span> <span class="ruby-identifier">server</span>
      <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">handler</span>.<span class="ruby-identifier">signature</span> = <span class="ruby-identifier">s</span>
  <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">handler</span>
  <span class="ruby-identifier">block_given?</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">handler</span>
  <span class="ruby-identifier">handler</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- reconnect-source -->
            
          </div>

          

          
        </div><!-- reconnect-method -->

      
        <div id="release_machine-method" class="method-detail ">
          <a name="method-c-release_machine"></a>

          
          <div class="method-heading">
            <span class="method-name">release_machine</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="release_machine-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">release_machine</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- release_machine-source -->
            
          </div>

          

          
        </div><!-- release_machine-method -->

      
        <div id="run-method" class="method-detail ">
          <a name="method-c-run"></a>

          
          <div class="method-heading">
            <span class="method-name">run</span><span
              class="method-args">(blk=nil, tail=nil, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Initializes and runs an event loop. This method only returns if code inside
the block passed to this method calls {<a
href="EventMachine.html#method-c-stop_event_loop">EventMachine.stop_event_loop</a>}.
The block is executed after initializing its internal event loop but
<b>before</b> running the loop, therefore this block is the right place to
call any code that needs event loop to run, for example, {<a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a>},
{<a href="EventMachine.html#method-c-connect">EventMachine.connect</a>} or
similar methods of libraries that use <a
href="EventMachine.html">EventMachine</a> under the hood (like
`EventMachine::HttpRequest.new` or `AMQP.start`).</p>

<p>Programs that are run for long periods of time (e.g. servers) usually start
event loop by calling {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>}, and let it run
“forever”. It’s also possible to use {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>} to make a
single client-connection to a remote server, process the data flow from
that single connection, and then call {<a
href="EventMachine.html#method-c-stop_event_loop">EventMachine.stop_event_loop</a>}
to stop, in other words, to run event loop for a short period of time
(necessary to complete some operation) and then shut it down.</p>

<p>Once event loop is running, it is perfectly possible to start multiple
servers and clients simultaneously: content-aware proxies like
[Proxymachine](<a
href="https://github.com/mojombo/proxymachine">github.com/mojombo/proxymachine</a>)
do just that.</p>

<p>## Using <a href="EventMachine.html">EventMachine</a> with Ruby on Rails
and other Web application frameworks ##</p>

<p>Standalone applications often run event loop on the main thread, thus
blocking for their entire lifespan. In case of Web applications, if you are
running an EventMachine-based app server such as [Thin](<a
href="http://code.macournoyer.com/thin/">code.macournoyer.com/thin/</a>) or
[Goliath](<a
href="https://github.com/postrank-labs/goliath/">github.com/postrank-labs/goliath/</a>),
they start event loop for you. Servers like Unicorn, Apache Passenger or
Mongrel occupy main Ruby thread to serve HTTP(S) requests. This means that
calling {<a href="EventMachine.html#method-c-run">EventMachine.run</a>} on
the same thread is not an option (it will result in Web server never
binding to the socket). In that case, start event loop in a separate thread
as demonstrated below.</p>

<p>@example Starting <a href="EventMachine.html">EventMachine</a> event loop
in the current thread to run the “Hello, world”-like Echo server example</p>

<pre>#!/usr/bin/env ruby

require 'rubygems' # or use Bundler.setup
require 'eventmachine'

class EchoServer &lt; EM::Connection
  def receive_data(data)
    send_data(data)
  end
end

EventMachine.run do
  EventMachine.start_server(&quot;0.0.0.0&quot;, 10000, EchoServer)
end</pre>

<p>@example Starting <a href="EventMachine.html">EventMachine</a> event loop
in a separate thread</p>

<pre># doesn't block current thread, can be used with Ruby on Rails, Sinatra, Merb, Rack
# and any other application server that occupies main Ruby thread.
Thread.new { EventMachine.run }</pre>

<p>@note This method blocks calling thread. If you need to start <a
href="EventMachine.html">EventMachine</a> event loop from a Web app</p>

<pre>running on a non event-driven server (Unicorn, Apache Passenger, Mongrel), do it in a separate thread like demonstrated
in one of the examples.</pre>

<p>@see file:<a href="docs/GettingStarted_md.html">docs/GettingStarted.md</a>
Getting started with <a href="EventMachine.html">EventMachine</a> @see <a
href="EventMachine.html#method-c-stop_event_loop">EventMachine.stop_event_loop</a></p>
            

            
            <div class="method-source-code" id="run-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 149</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">run</span> <span class="ruby-identifier">blk</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">tail</span>=<span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-comment"># Obsoleted the use_threads mechanism.</span>
  <span class="ruby-comment"># 25Nov06: Added the begin/ensure block. We need to be sure that release_machine</span>
  <span class="ruby-comment"># gets called even if an exception gets thrown within any of the user code</span>
  <span class="ruby-comment"># that the event loop runs. The best way to see this is to run a unit</span>
  <span class="ruby-comment"># test with two functions, each of which calls {EventMachine.run} and each of</span>
  <span class="ruby-comment"># which throws something inside of #run. Without the ensure, the second test</span>
  <span class="ruby-comment"># will start without release_machine being called and will immediately throw</span>

  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@reactor_running</span> <span class="ruby-keyword">and</span> <span class="ruby-ivar">@reactor_pid</span> <span class="ruby-operator">!=</span> <span class="ruby-constant">Process</span>.<span class="ruby-identifier">pid</span>
    <span class="ruby-comment"># Reactor was started in a different parent, meaning we have forked.</span>
    <span class="ruby-comment"># Clean up reactor state so a new reactor boots up in this child.</span>
    <span class="ruby-identifier">stop_event_loop</span>
    <span class="ruby-identifier">release_machine</span>
    <span class="ruby-identifier">cleanup_machine</span>
    <span class="ruby-ivar">@reactor_running</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">tail</span> <span class="ruby-keyword">and</span> <span class="ruby-ivar">@tails</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">tail</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">reactor_running?</span>
    (<span class="ruby-identifier">b</span> = <span class="ruby-identifier">blk</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">block</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span> <span class="ruby-comment"># next_tick(b)</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@conns</span> = {}
    <span class="ruby-ivar">@acceptors</span> = {}
    <span class="ruby-ivar">@timers</span> = {}
    <span class="ruby-ivar">@wrapped_exception</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-ivar">@next_tick_queue</span> <span class="ruby-operator">||=</span> []
    <span class="ruby-ivar">@tails</span> <span class="ruby-operator">||=</span> []
    <span class="ruby-keyword">begin</span>
      <span class="ruby-ivar">@reactor_pid</span> = <span class="ruby-constant">Process</span>.<span class="ruby-identifier">pid</span>
      <span class="ruby-ivar">@reactor_running</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-identifier">initialize_event_machine</span>
      (<span class="ruby-identifier">b</span> = <span class="ruby-identifier">blk</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">block</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">add_timer</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">b</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-ivar">@next_tick_queue</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@next_tick_queue</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-identifier">add_timer</span>(<span class="ruby-value">0</span>) { <span class="ruby-identifier">signal_loopbreak</span> }
      <span class="ruby-keyword">end</span>
      <span class="ruby-ivar">@reactor_thread</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>

      <span class="ruby-comment"># Rubinius needs to come back into &quot;Ruby space&quot; for GC to work,</span>
      <span class="ruby-comment"># so we'll crank the machine here.</span>
      <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-constant">RUBY_ENGINE</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">RUBY_ENGINE</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;rbx&quot;</span>
        <span class="ruby-keyword">while</span> <span class="ruby-identifier">run_machine_once</span>; <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">run_machine</span>
      <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">ensure</span>
      <span class="ruby-keyword">until</span> <span class="ruby-ivar">@tails</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-ivar">@tails</span>.<span class="ruby-identifier">pop</span>.<span class="ruby-identifier">call</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">release_machine</span>
      <span class="ruby-identifier">cleanup_machine</span>
      <span class="ruby-ivar">@reactor_running</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-ivar">@reactor_thread</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">raise</span> <span class="ruby-ivar">@wrapped_exception</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@wrapped_exception</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- run-source -->
            
          </div>

          

          
        </div><!-- run-method -->

      
        <div id="run_block-method" class="method-detail ">
          <a name="method-c-run_block"></a>

          
          <div class="method-heading">
            <span class="method-name">run_block</span><span
              class="method-args">(&block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sugars a common use case. Will pass the given block to run, but will
terminate the reactor loop and exit the function as soon as the code in the
block completes. (Normally, {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>} keeps running
indefinitely, even after the block supplied to it finishes running, until
user code calls {<a
href="EventMachine.html#method-c-stop">EventMachine.stop</a>})</p>
            

            
            <div class="method-source-code" id="run_block-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 217</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">run_block</span> &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-identifier">pr</span> = <span class="ruby-identifier">proc</span> {
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>
    <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">stop</span>
  }
  <span class="ruby-identifier">run</span>(&amp;<span class="ruby-identifier">pr</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- run_block-source -->
            
          </div>

          

          
        </div><!-- run_block-method -->

      
        <div id="run_deferred_callbacks-method" class="method-detail ">
          <a name="method-c-run_deferred_callbacks"></a>

          
          <div class="method-heading">
            <span class="method-name">run_deferred_callbacks</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The is the responder for the loopback-signalled event. It can be fired
either by code running on a separate thread ({<a
href="EventMachine.html#method-c-defer">EventMachine.defer</a>}) or on the
main thread ({<a
href="EventMachine.html#method-c-next_tick">EventMachine.next_tick</a>}).
It will often happen that a <a
href="EventMachine.html#method-c-next_tick">next_tick</a> handler will
reschedule itself. We consume a copy of the tick queue so that tick events
scheduled by tick events have to wait for the next pass through the reactor
core.</p>

<p>@private</p>
            

            
            <div class="method-source-code" id="run_deferred_callbacks-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 966</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">run_deferred_callbacks</span>
  <span class="ruby-keyword">until</span> (<span class="ruby-ivar">@resultqueue</span> <span class="ruby-operator">||=</span> []).<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">result</span>,<span class="ruby-identifier">cback</span> = <span class="ruby-ivar">@resultqueue</span>.<span class="ruby-identifier">pop</span>
    <span class="ruby-identifier">cback</span>.<span class="ruby-identifier">call</span> <span class="ruby-identifier">result</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">cback</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Capture the size at the start of this tick...</span>
  <span class="ruby-identifier">size</span> = <span class="ruby-ivar">@next_tick_mutex</span>.<span class="ruby-identifier">synchronize</span> { <span class="ruby-ivar">@next_tick_queue</span>.<span class="ruby-identifier">size</span> }
  <span class="ruby-identifier">size</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">callback</span> = <span class="ruby-ivar">@next_tick_mutex</span>.<span class="ruby-identifier">synchronize</span> { <span class="ruby-ivar">@next_tick_queue</span>.<span class="ruby-identifier">shift</span> }
    <span class="ruby-keyword">begin</span>
      <span class="ruby-identifier">callback</span>.<span class="ruby-identifier">call</span>
    <span class="ruby-keyword">rescue</span>
      <span class="ruby-identifier">exception_raised</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-identifier">raise</span>
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-comment"># This is a little nasty. The problem is, if an exception occurs during</span>
      <span class="ruby-comment"># the callback, then we need to send a signal to the reactor to actually</span>
      <span class="ruby-comment"># do some work during the next_tick. The only mechanism we have from the</span>
      <span class="ruby-comment"># ruby side is next_tick itself, although ideally, we'd just drop a byte</span>
      <span class="ruby-comment"># on the loopback descriptor.</span>
      <span class="ruby-constant">EM</span>.<span class="ruby-identifier">next_tick</span> {} <span class="ruby-keyword">if</span> <span class="ruby-identifier">exception_raised</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- run_deferred_callbacks-source -->
            
          </div>

          

          
        </div><!-- run_deferred_callbacks-method -->

      
        <div id="run_machine-method" class="method-detail ">
          <a name="method-c-run_machine"></a>

          
          <div class="method-heading">
            <span class="method-name">run_machine</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="run_machine-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">run_machine</span>
  <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">run</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- run_machine-source -->
            
          </div>

          

          
        </div><!-- run_machine-method -->

      
        <div id="schedule-method" class="method-detail ">
          <a name="method-c-schedule"></a>

          
          <div class="method-heading">
            <span class="method-name">schedule</span><span
              class="method-args">(*a, &b)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Runs the given callback on the reactor thread, or immediately if called
from the reactor thread. Accepts the same arguments as
{EventMachine::Callback}</p>
            

            
            <div class="method-source-code" id="schedule-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 232</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">schedule</span>(*<span class="ruby-identifier">a</span>, &amp;<span class="ruby-identifier">b</span>)
  <span class="ruby-identifier">cb</span> = <span class="ruby-constant">Callback</span>(*<span class="ruby-identifier">a</span>, &amp;<span class="ruby-identifier">b</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">reactor_running?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">reactor_thread?</span>
    <span class="ruby-identifier">cb</span>.<span class="ruby-identifier">call</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">next_tick</span> { <span class="ruby-identifier">cb</span>.<span class="ruby-identifier">call</span> }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- schedule-source -->
            
          </div>

          

          
        </div><!-- schedule-method -->

      
        <div id="send_data-method" class="method-detail ">
          <a name="method-c-send_data"></a>

          
          <div class="method-heading">
            <span class="method-name">send_data</span><span
              class="method-args">(target, data, datalength)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="send_data-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_data</span> <span class="ruby-identifier">target</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">datalength</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>( <span class="ruby-identifier">target</span> ) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown send_data target&quot;</span>
  <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">send_data</span> <span class="ruby-identifier">data</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- send_data-source -->
            
          </div>

          

          
        </div><!-- send_data-method -->

      
        <div id="send_datagram-method" class="method-detail ">
          <a name="method-c-send_datagram"></a>

          
          <div class="method-heading">
            <span class="method-name">send_datagram</span><span
              class="method-args">(target, data, datalength, host, port)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This is currently only for UDP! We need to make it work with unix-domain
sockets as well. @private</p>
            

            
            <div class="method-source-code" id="send_datagram-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_datagram</span> <span class="ruby-identifier">target</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">datalength</span>, <span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>( <span class="ruby-identifier">target</span> ) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown send_data target&quot;</span>
  <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">send_datagram</span> <span class="ruby-identifier">data</span>, <span class="ruby-constant">Socket</span><span class="ruby-operator">::</span><span class="ruby-identifier">pack_sockaddr_in</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">host</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- send_datagram-source -->
            
          </div>

          

          
        </div><!-- send_datagram-method -->

      
        <div id="send_file_data-method" class="method-detail ">
          <a name="method-c-send_file_data"></a>

          
          <div class="method-heading">
            <span class="method-name">send_file_data</span><span
              class="method-args">(sig, filename)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="send_file_data-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 393</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_file_data</span> <span class="ruby-identifier">sig</span>, <span class="ruby-identifier">filename</span>
  <span class="ruby-identifier">sz</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">size</span>(<span class="ruby-identifier">filename</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;file too large&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">sz</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">32</span>*<span class="ruby-value">1024</span>
  <span class="ruby-identifier">data</span> =
    <span class="ruby-keyword">begin</span>
      <span class="ruby-constant">File</span>.<span class="ruby-identifier">read</span> <span class="ruby-identifier">filename</span>
    <span class="ruby-keyword">rescue</span>
      <span class="ruby-string">&quot;&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">send_data</span> <span class="ruby-identifier">sig</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">data</span>.<span class="ruby-identifier">length</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- send_file_data-source -->
            
          </div>

          

          
        </div><!-- send_file_data-method -->

      
        <div id="set_comm_inactivity_timeout-method" class="method-detail ">
          <a name="method-c-set_comm_inactivity_timeout"></a>

          
          <div class="method-heading">
            <span class="method-name">set_comm_inactivity_timeout</span><span
              class="method-args">(sig, tm)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="set_comm_inactivity_timeout-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 417</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_comm_inactivity_timeout</span> <span class="ruby-identifier">sig</span>, <span class="ruby-identifier">tm</span>
  <span class="ruby-identifier">r</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>( <span class="ruby-identifier">sig</span> ) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown set_comm_inactivity_timeout target&quot;</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">set_inactivity_timeout</span> <span class="ruby-identifier">tm</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_comm_inactivity_timeout-source -->
            
          </div>

          

          
        </div><!-- set_comm_inactivity_timeout-method -->

      
        <div id="set_descriptor_table_size-method" class="method-detail ">
          <a name="method-c-set_descriptor_table_size"></a>

          
          <div class="method-heading">
            <span class="method-name">set_descriptor_table_size</span><span
              class="method-args">(n_descriptors=nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sets the maximum number of file or socket descriptors that your process may
open. If you call this method with no arguments, it will simply return the
current size of the descriptor table without attempting to change it.</p>

<p>The new limit on open descriptors *<b>only</b>* applies to sockets and
other descriptors that belong to <a
href="EventMachine.html">EventMachine</a>. It has **no effect** on the
number of descriptors you can create in ordinary Ruby code.</p>

<p>Not available on all platforms. Increasing the number of descriptors beyond
its default limit usually requires superuser privileges. (See {.<a
href="EventMachine.html#method-c-set_effective_user">set_effective_user</a>}
for a way to drop superuser privileges while your program is running.)</p>

<p>@param [Integer] n_descriptors The maximum number of file or socket
descriptors that your process may open @return [Integer] The new descriptor
table size.</p>
            

            
            <div class="method-source-code" id="set_descriptor_table_size-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1167</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">set_descriptor_table_size</span> <span class="ruby-identifier">n_descriptors</span>=<span class="ruby-keyword">nil</span>
  <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">set_rlimit_nofile</span> <span class="ruby-identifier">n_descriptors</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_descriptor_table_size-source -->
            
          </div>

          

          
        </div><!-- set_descriptor_table_size-method -->

      
        <div id="set_effective_user-method" class="method-detail ">
          <a name="method-c-set_effective_user"></a>

          
          <div class="method-heading">
            <span class="method-name">set_effective_user</span><span
              class="method-args">(username)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>A wrapper over the setuid system call. Particularly useful when opening a
network server on a privileged port because you can use this call to drop
privileges after opening the port. Also very useful after a call to {.<a
href="EventMachine.html#method-c-set_descriptor_table_size">set_descriptor_table_size</a>},
which generally requires that you start your process with root privileges.</p>

<p>This method is intended for use in enforcing security requirements,
consequently it will throw a fatal error and end your program if it fails.</p>

<p>@param [String] username The effective name of the user whose
privilege-level your process should attain.</p>

<p>@note This method has no effective implementation on Windows or in the
pure-Ruby</p>

<pre>implementation of EventMachine</pre>
            

            
            <div class="method-source-code" id="set_effective_user-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1148</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">set_effective_user</span> <span class="ruby-identifier">username</span>
  <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">setuid_string</span> <span class="ruby-identifier">username</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_effective_user-source -->
            
          </div>

          

          
        </div><!-- set_effective_user-method -->

      
        <div id="set_max_timer_count-method" class="method-detail ">
          <a name="method-c-set_max_timer_count"></a>

          
          <div class="method-heading">
            <span class="method-name">set_max_timer_count</span><span
              class="method-args">(n)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This method is a harmless no-op in pure Ruby, which doesn’t have a built-in
limit on the number of available timers. @private</p>
            

            
            <div class="method-source-code" id="set_max_timer_count-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 377</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_max_timer_count</span> <span class="ruby-identifier">n</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_max_timer_count-source -->
            
          </div>

          

          
        </div><!-- set_max_timer_count-method -->

      
        <div id="set_max_timers-method" class="method-detail ">
          <a name="method-c-set_max_timers"></a>

          
          <div class="method-heading">
            <span class="method-name">set_max_timers</span><span
              class="method-args">(ct)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sets the maximum number of timers and periodic timers that may be
outstanding at any given time. You only need to call {.<a
href="EventMachine.html#method-c-set_max_timers">set_max_timers</a>} if you
need more than the default number of timers, which on most platforms is
1000.</p>

<p>@note This method has to be used <b>before</b> event loop is started.</p>

<p>@param [Integer] ct Maximum number of timers that may be outstanding at any
given time</p>

<p>@see <a
href="EventMachine.html#method-c-add_timer">EventMachine.add_timer</a> @see
<a
href="EventMachine.html#method-c-add_periodic_timer">EventMachine.add_periodic_timer</a>
@see <a href="EventMachine/Timer.html">EventMachine::Timer</a></p>
            

            
            <div class="method-source-code" id="set_max_timers-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 916</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">set_max_timers</span> <span class="ruby-identifier">ct</span>
  <span class="ruby-identifier">set_max_timer_count</span> <span class="ruby-identifier">ct</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_max_timers-source -->
            
          </div>

          

          
        </div><!-- set_max_timers-method -->

      
        <div id="set_pending_connect_timeout-method" class="method-detail ">
          <a name="method-c-set_pending_connect_timeout"></a>

          
          <div class="method-heading">
            <span class="method-name">set_pending_connect_timeout</span><span
              class="method-args">(sig, tm)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="set_pending_connect_timeout-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 423</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_pending_connect_timeout</span> <span class="ruby-identifier">sig</span>, <span class="ruby-identifier">tm</span>
  <span class="ruby-comment"># Needs to be implemented. Currently a no-op stub to allow</span>
  <span class="ruby-comment"># certain software to operate with the EM pure-ruby.</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_pending_connect_timeout-source -->
            
          </div>

          

          
        </div><!-- set_pending_connect_timeout-method -->

      
        <div id="set_quantum-method" class="method-detail ">
          <a name="method-c-set_quantum"></a>

          
          <div class="method-heading">
            <span class="method-name">set_quantum</span><span
              class="method-args">(mills)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>For advanced users. This function sets the default timer granularity, which
by default is slightly smaller than 100 milliseconds. Call this function to
set a higher or lower granularity. The function affects the behavior of {<a
href="EventMachine.html#method-c-add_timer">EventMachine.add_timer</a>} and
{<a
href="EventMachine.html#method-c-add_periodic_timer">EventMachine.add_periodic_timer</a>}.
Most applications will not need to call this function.</p>

<p>Avoid setting the quantum to very low values because that may reduce
performance under some extreme conditions. We recommend that you not use
values lower than 10.</p>

<p>This method only can be used if event loop is running.</p>

<p>@param [Integer] mills New timer granularity, in milliseconds</p>

<p>@see <a
href="EventMachine.html#method-c-add_timer">EventMachine.add_timer</a> @see
<a
href="EventMachine.html#method-c-add_periodic_timer">EventMachine.add_periodic_timer</a>
@see <a href="EventMachine/Timer.html">EventMachine::Timer</a> @see <a
href="EventMachine.html#method-c-run">EventMachine.run</a></p>
            

            
            <div class="method-source-code" id="set_quantum-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 901</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">set_quantum</span> <span class="ruby-identifier">mills</span>
  <span class="ruby-identifier">set_timer_quantum</span> <span class="ruby-identifier">mills</span>.<span class="ruby-identifier">to_i</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_quantum-source -->
            
          </div>

          

          
        </div><!-- set_quantum-method -->

      
        <div id="set_rlimit_nofile-method" class="method-detail ">
          <a name="method-c-set_rlimit_nofile"></a>

          
          <div class="method-heading">
            <span class="method-name">set_rlimit_nofile</span><span
              class="method-args">(n)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This method is a no-op in the pure-Ruby implementation. We simply return
Ruby’s built-in per-process file-descriptor limit. @private</p>
            

            
            <div class="method-source-code" id="set_rlimit_nofile-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 370</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_rlimit_nofile</span> <span class="ruby-identifier">n</span>
  <span class="ruby-value">1024</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_rlimit_nofile-source -->
            
          </div>

          

          
        </div><!-- set_rlimit_nofile-method -->

      
        <div id="set_sock_opt-method" class="method-detail ">
          <a name="method-c-set_sock_opt"></a>

          
          <div class="method-heading">
            <span class="method-name">set_sock_opt</span><span
              class="method-args">(signature, level, optname, optval)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="set_sock_opt-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 387</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_sock_opt</span> <span class="ruby-identifier">signature</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">optname</span>, <span class="ruby-identifier">optval</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>( <span class="ruby-identifier">signature</span> ) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown set_sock_opt target&quot;</span>
  <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">setsockopt</span> <span class="ruby-identifier">level</span>, <span class="ruby-identifier">optname</span>, <span class="ruby-identifier">optval</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_sock_opt-source -->
            
          </div>

          

          
        </div><!-- set_sock_opt-method -->

      
        <div id="set_timer_quantum-method" class="method-detail ">
          <a name="method-c-set_timer_quantum"></a>

          
          <div class="method-heading">
            <span class="method-name">set_timer_quantum</span><span
              class="method-args">(interval)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sets reactor quantum in milliseconds. The underlying <a
href="EventMachine/Reactor.html">Reactor</a> function wants a (possibly
fractional) number of seconds. @private</p>
            

            
            <div class="method-source-code" id="set_timer_quantum-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_timer_quantum</span> <span class="ruby-identifier">interval</span>
  <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">set_timer_quantum</span>(( <span class="ruby-value">1.0</span> * <span class="ruby-identifier">interval</span>) <span class="ruby-operator">/</span> <span class="ruby-value">1000.0</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_timer_quantum-source -->
            
          </div>

          

          
        </div><!-- set_timer_quantum-method -->

      
        <div id="set_tls_parms-method" class="method-detail ">
          <a name="method-c-set_tls_parms"></a>

          
          <div class="method-heading">
            <span class="method-name">set_tls_parms</span><span
              class="method-args">(signature, priv_key, cert_chain, verify_peer, fail_if_no_peer_cert, sni_hostname, cipher_list, ecdh_curve, dhparam, protocols_bitmask)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>This method takes a series of positional arguments for specifying such
things as private keys and certificate chains. It’s expected that the
parameter list will grow as we add more supported features. ALL of these
parameters are optional, and can be specified as empty or nil strings.
@private</p>
            

            
            <div class="method-source-code" id="set_tls_parms-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 258</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_tls_parms</span> <span class="ruby-identifier">signature</span>, <span class="ruby-identifier">priv_key</span>, <span class="ruby-identifier">cert_chain</span>, <span class="ruby-identifier">verify_peer</span>, <span class="ruby-identifier">fail_if_no_peer_cert</span>, <span class="ruby-identifier">sni_hostname</span>, <span class="ruby-identifier">cipher_list</span>, <span class="ruby-identifier">ecdh_curve</span>, <span class="ruby-identifier">dhparam</span>, <span class="ruby-identifier">protocols_bitmask</span>
  <span class="ruby-identifier">bitmask</span> = <span class="ruby-identifier">protocols_bitmask</span>
  <span class="ruby-identifier">ssl_options</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_ALL</span>
  <span class="ruby-identifier">ssl_options</span> <span class="ruby-operator">|=</span> <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_NO_SSLv2</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_NO_SSLv2</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">EM_PROTO_SSLv2</span> &amp; <span class="ruby-identifier">bitmask</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
  <span class="ruby-identifier">ssl_options</span> <span class="ruby-operator">|=</span> <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_NO_SSLv3</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_NO_SSLv3</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">EM_PROTO_SSLv3</span> &amp; <span class="ruby-identifier">bitmask</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
  <span class="ruby-identifier">ssl_options</span> <span class="ruby-operator">|=</span> <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_NO_TLSv1</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_NO_TLSv1</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">EM_PROTO_TLSv1</span> &amp; <span class="ruby-identifier">bitmask</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
  <span class="ruby-identifier">ssl_options</span> <span class="ruby-operator">|=</span> <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_NO_TLSv1_1</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_NO_TLSv1_1</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">EM_PROTO_TLSv1_1</span> &amp; <span class="ruby-identifier">bitmask</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
  <span class="ruby-identifier">ssl_options</span> <span class="ruby-operator">|=</span> <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_NO_TLSv1_2</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">OP_NO_TLSv1_2</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">EM_PROTO_TLSv1_2</span> &amp; <span class="ruby-identifier">bitmask</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
  <span class="ruby-ivar">@tls_parms</span> <span class="ruby-operator">||=</span> {}
  <span class="ruby-ivar">@tls_parms</span>[<span class="ruby-identifier">signature</span>] = {
    <span class="ruby-value">:verify_peer</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">verify_peer</span>,
    <span class="ruby-value">:fail_if_no_peer_cert</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">fail_if_no_peer_cert</span>,
    <span class="ruby-value">:ssl_options</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">ssl_options</span>
  }
  <span class="ruby-ivar">@tls_parms</span>[<span class="ruby-identifier">signature</span>][<span class="ruby-value">:priv_key</span>] = <span class="ruby-constant">File</span>.<span class="ruby-identifier">read</span>(<span class="ruby-identifier">priv_key</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parm_set?</span>(<span class="ruby-identifier">priv_key</span>)
  <span class="ruby-ivar">@tls_parms</span>[<span class="ruby-identifier">signature</span>][<span class="ruby-value">:cert_chain</span>] = <span class="ruby-constant">File</span>.<span class="ruby-identifier">read</span>(<span class="ruby-identifier">cert_chain</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parm_set?</span>(<span class="ruby-identifier">cert_chain</span>)
  <span class="ruby-ivar">@tls_parms</span>[<span class="ruby-identifier">signature</span>][<span class="ruby-value">:sni_hostname</span>] = <span class="ruby-identifier">sni_hostname</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parm_set?</span>(<span class="ruby-identifier">sni_hostname</span>)
  <span class="ruby-ivar">@tls_parms</span>[<span class="ruby-identifier">signature</span>][<span class="ruby-value">:cipher_list</span>] = <span class="ruby-identifier">cipher_list</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/,\s*/</span>, <span class="ruby-string">':'</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parm_set?</span>(<span class="ruby-identifier">cipher_list</span>)
  <span class="ruby-ivar">@tls_parms</span>[<span class="ruby-identifier">signature</span>][<span class="ruby-value">:dhparam</span>] = <span class="ruby-constant">File</span>.<span class="ruby-identifier">read</span>(<span class="ruby-identifier">dhparam</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parm_set?</span>(<span class="ruby-identifier">dhparam</span>)
  <span class="ruby-ivar">@tls_parms</span>[<span class="ruby-identifier">signature</span>][<span class="ruby-value">:ecdh_curve</span>] = <span class="ruby-identifier">ecdh_curve</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parm_set?</span>(<span class="ruby-identifier">ecdh_curve</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- set_tls_parms-source -->
            
          </div>

          

          
        </div><!-- set_tls_parms-method -->

      
        <div id="signal_loopbreak-method" class="method-detail ">
          <a name="method-c-signal_loopbreak"></a>

          
          <div class="method-heading">
            <span class="method-name">signal_loopbreak</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="signal_loopbreak-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">signal_loopbreak</span>
  <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">signal_loopbreak</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- signal_loopbreak-source -->
            
          </div>

          

          
        </div><!-- signal_loopbreak-method -->

      
        <div id="spawn-method" class="method-detail ">
          <a name="method-c-spawn"></a>

          
          <div class="method-heading">
            <span class="method-name">spawn</span><span
              class="method-args">(&block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Spawn an erlang-style process</p>
            

            
            <div class="method-source-code" id="spawn-source">
<pre>
<span class="ruby-comment"># File lib/em/spawnable.rb, line 69</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">spawn</span> &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-identifier">s</span> = <span class="ruby-constant">SpawnedProcess</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">s</span>.<span class="ruby-identifier">set_receiver</span> <span class="ruby-identifier">block</span>
  <span class="ruby-identifier">s</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- spawn-source -->
            
          </div>

          

          
        </div><!-- spawn-method -->

      
        <div id="spawn_threadpool-method" class="method-detail ">
          <a name="method-c-spawn_threadpool"></a>

          
          <div class="method-heading">
            <span class="method-name">spawn_threadpool</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="spawn_threadpool-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1064</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">spawn_threadpool</span>
  <span class="ruby-keyword">until</span> <span class="ruby-ivar">@threadpool</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-ivar">@threadpool_size</span>.<span class="ruby-identifier">to_i</span>
    <span class="ruby-identifier">thread</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
      <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">abort_on_exception</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">begin</span>
          <span class="ruby-identifier">op</span>, <span class="ruby-identifier">cback</span>, <span class="ruby-identifier">eback</span> = *<span class="ruby-ivar">@threadqueue</span>.<span class="ruby-identifier">pop</span>
        <span class="ruby-keyword">rescue</span> <span class="ruby-constant">ThreadError</span>
          <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-identifier">$!</span>.<span class="ruby-identifier">message</span>
          <span class="ruby-keyword">break</span> <span class="ruby-comment"># Ruby 2.0 may fail at Queue.pop</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">begin</span>
          <span class="ruby-identifier">result</span> = <span class="ruby-identifier">op</span>.<span class="ruby-identifier">call</span>
          <span class="ruby-ivar">@resultqueue</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">result</span>, <span class="ruby-identifier">cback</span>]
        <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Exception</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">error</span>
          <span class="ruby-identifier">raise</span> <span class="ruby-identifier">error</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">eback</span>
          <span class="ruby-ivar">@resultqueue</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">error</span>, <span class="ruby-identifier">eback</span>]
        <span class="ruby-keyword">end</span>
        <span class="ruby-constant">EventMachine</span>.<span class="ruby-identifier">signal_loopbreak</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-ivar">@threadpool</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">thread</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-ivar">@all_threads_spawned</span> = <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- spawn_threadpool-source -->
            
          </div>

          

          
        </div><!-- spawn_threadpool-method -->

      
        <div id="ssl-3F-method" class="method-detail ">
          <a name="method-c-ssl-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">ssl?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="ssl-3F-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 245</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ssl?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- ssl-3F-source -->
            
          </div>

          

          
        </div><!-- ssl-3F-method -->

      
        <div id="start_server-method" class="method-detail ">
          <a name="method-c-start_server"></a>

          
          <div class="method-heading">
            <span class="method-name">start_server</span><span
              class="method-args">(server, port=nil, handler=nil, *args, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Initiates a TCP server (socket acceptor) on the specified IP address and
port.</p>

<p>The IP address must be valid on the machine where the program runs, and the
process must be privileged enough to listen on the specified port (on
Unix-like systems, superuser privileges are usually required to listen on
any port lower than 1024). Only one listener may be running on any given
address/port combination. <a
href="EventMachine.html#method-c-start_server">start_server</a> will fail
if the given address and port are already listening on the machine, either
because of a prior call to {.<a
href="EventMachine.html#method-c-start_server">start_server</a>} or some
unrelated process running on the machine. If {.<a
href="EventMachine.html#method-c-start_server">start_server</a>} succeeds,
the new network listener becomes active immediately and starts accepting
connections from remote peers, and these connections generate callback
events that are processed by the code specified in the handler parameter to
{.<a href="EventMachine.html#method-c-start_server">start_server</a>}.</p>

<p>The optional handler which is passed to this method is the key to
EventMachine’s ability to handle particular network protocols. The handler
parameter passed to <a
href="EventMachine.html#method-c-start_server">start_server</a> must be a
Ruby Module that you must define. When the network server that is started
by <a href="EventMachine.html#method-c-start_server">start_server</a>
accepts a new connection, it instantiates a new object of an anonymous
class that is inherited from {EventMachine::Connection}, *into which your
handler module have been included*. Arguments passed into <a
href="EventMachine.html#method-c-start_server">start_server</a> after the
class name are passed into the constructor during the instantiation.</p>

<p>Your handler module may override any of the methods in
{EventMachine::Connection}, such as {<a
href="EventMachine/Connection.html#method-i-receive_data">EventMachine::Connection#receive_data</a>},
in order to implement the specific behavior of the network protocol.</p>

<p>Callbacks invoked in response to network events <b>always</b> take place
within the execution context of the object derived from
{EventMachine::Connection} extended by your handler module. There is one
object per connection, and all of the callbacks invoked for a particular
connection take the form of instance methods called against the
corresponding {EventMachine::Connection} object. Therefore, you are free to
define whatever instance variables you wish, in order to contain the
per-connection state required by the network protocol you are implementing.</p>

<p>{<a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a>}
is usually called inside the block passed to {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>}, but it can be
called from any <a href="EventMachine.html">EventMachine</a> callback. {<a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a>}
will fail unless the <a href="EventMachine.html">EventMachine</a> event
loop is currently running (which is why it’s often called in the block
suppled to {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>}).</p>

<p>You may call <a
href="EventMachine.html#method-c-start_server">start_server</a> any number
of times to start up network listeners on different address/port
combinations. The servers will all run simultaneously. More interestingly,
each individual call to <a
href="EventMachine.html#method-c-start_server">start_server</a> can specify
a different handler module and thus implement a different network protocol
from all the others.</p>

<p>@example</p>

<pre>require 'rubygems'
require 'eventmachine'

# Here is an example of a server that counts lines of input from the remote
# peer and sends back the total number of lines received, after each line.
# Try the example with more than one client connection opened via telnet,
# and you will see that the line count increments independently on each
# of the client connections. Also very important to note, is that the
# handler for the receive_data function, which our handler redefines, may
# not assume that the data it receives observes any kind of message boundaries.
# Also, to use this example, be sure to change the server and port parameters
# to the start_server call to values appropriate for your environment.
module LineCounter
  MaxLinesPerConnection = 10

  def post_init
    puts &quot;Received a new connection&quot;
    @data_received = &quot;&quot;
    @line_count = 0
  end

  def receive_data data
    @data_received &lt;&lt; data
    while @data_received.slice!( /^[^\n]*[\n]/m )
      @line_count += 1
      send_data &quot;received #{@line_count} lines so far\r\n&quot;
      @line_count == MaxLinesPerConnection and close_connection_after_writing
    end
  end
end

EventMachine.run {
  host, port = &quot;192.168.0.100&quot;, 8090
  EventMachine.start_server host, port, LineCounter
  puts &quot;Now accepting connections on address #{host}, port #{port}...&quot;
  EventMachine.add_periodic_timer(10) { $stderr.write &quot;*&quot; }
}</pre>

<p>@param [String] server         Host to bind to. @param [Integer] port      
Port to bind to. @param [Module, Class] handler A module or class that
implements connection callbacks</p>

<p>@note Don’t forget that in order to bind to ports &lt; 1024 on Linux, *BSD
and Mac OS X your process must have superuser privileges.</p>

<p>@see file:<a href="docs/GettingStarted_md.html">docs/GettingStarted.md</a>
<a href="EventMachine.html">EventMachine</a> tutorial @see <a
href="EventMachine.html#method-c-stop_server">EventMachine.stop_server</a></p>
            

            
            <div class="method-source-code" id="start_server-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 516</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">start_server</span> <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">port</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-identifier">port</span>)
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-constant">TypeError</span>
    <span class="ruby-comment"># there was no port, so server must be a unix domain socket</span>
    <span class="ruby-comment"># the port argument is actually the handler, and the handler is one of the args</span>
    <span class="ruby-identifier">args</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">handler</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">handler</span>
    <span class="ruby-identifier">handler</span> = <span class="ruby-identifier">port</span>
    <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">port</span>

  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-constant">Connection</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>)

  <span class="ruby-identifier">s</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">port</span>
        <span class="ruby-identifier">start_tcp_server</span> <span class="ruby-identifier">server</span>, <span class="ruby-identifier">port</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">start_unix_server</span> <span class="ruby-identifier">server</span>
      <span class="ruby-keyword">end</span>
  <span class="ruby-ivar">@acceptors</span>[<span class="ruby-identifier">s</span>] = [<span class="ruby-identifier">klass</span>,<span class="ruby-identifier">args</span>,<span class="ruby-identifier">block</span>]
  <span class="ruby-identifier">s</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- start_server-source -->
            
          </div>

          

          
        </div><!-- start_server-method -->

      
        <div id="start_tcp_server-method" class="method-detail ">
          <a name="method-c-start_tcp_server"></a>

          
          <div class="method-heading">
            <span class="method-name">start_tcp_server</span><span
              class="method-args">(host, port)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="start_tcp_server-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start_tcp_server</span> <span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>
  (<span class="ruby-identifier">s</span> = <span class="ruby-constant">EvmaTCPServer</span>.<span class="ruby-identifier">start_server</span> <span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;no acceptor&quot;</span>
  <span class="ruby-identifier">s</span>.<span class="ruby-identifier">uuid</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- start_tcp_server-source -->
            
          </div>

          

          
        </div><!-- start_tcp_server-method -->

      
        <div id="start_tls-method" class="method-detail ">
          <a name="method-c-start_tls"></a>

          
          <div class="method-heading">
            <span class="method-name">start_tls</span><span
              class="method-args">(signature)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="start_tls-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 280</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start_tls</span> <span class="ruby-identifier">signature</span>
  <span class="ruby-identifier">selectable</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>(<span class="ruby-identifier">signature</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;unknown io selectable for start_tls&quot;</span>
  <span class="ruby-identifier">tls_parms</span> = <span class="ruby-ivar">@tls_parms</span>[<span class="ruby-identifier">signature</span>]
  <span class="ruby-identifier">ctx</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSLContext</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">options</span> = <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:ssl_options</span>]
  <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">cert</span> = <span class="ruby-constant">DefaultCertificate</span>.<span class="ruby-identifier">cert</span>
  <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">key</span> = <span class="ruby-constant">DefaultCertificate</span>.<span class="ruby-identifier">key</span>
  <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">cert_store</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">X509</span><span class="ruby-operator">::</span><span class="ruby-constant">Store</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">cert_store</span>.<span class="ruby-identifier">set_default_paths</span>
  <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">cert</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">X509</span><span class="ruby-operator">::</span><span class="ruby-constant">Certificate</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:cert_chain</span>]) <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:cert_chain</span>]
  <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">key</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">PKey</span><span class="ruby-operator">::</span><span class="ruby-constant">RSA</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:priv_key</span>]) <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:priv_key</span>]
  <span class="ruby-identifier">verify_mode</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">VERIFY_NONE</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:verify_peer</span>]
    <span class="ruby-identifier">verify_mode</span> <span class="ruby-operator">|=</span> <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">VERIFY_PEER</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:fail_if_no_peer_cert</span>]
    <span class="ruby-identifier">verify_mode</span> <span class="ruby-operator">|=</span> <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">VERIFY_FAIL_IF_NO_PEER_CERT</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">verify_mode</span> = <span class="ruby-identifier">verify_mode</span>
  <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">servername_cb</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">_</span>, <span class="ruby-identifier">server_name</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:server_name</span>] = <span class="ruby-identifier">server_name</span>
    <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">ciphers</span> = <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:cipher_list</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:cipher_list</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">is_server</span>
    <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">tmp_dh_callback</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">_</span>, <span class="ruby-identifier">_</span>, <span class="ruby-identifier">key_length</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:dhparam</span>]
        <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">PKey</span><span class="ruby-operator">::</span><span class="ruby-constant">DH</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:dhparam</span>])
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">case</span> <span class="ruby-identifier">key_length</span>
        <span class="ruby-keyword">when</span> <span class="ruby-value">1024</span> <span class="ruby-keyword">then</span> <span class="ruby-constant">DefaultDHKey1024</span>
        <span class="ruby-keyword">when</span> <span class="ruby-value">2048</span> <span class="ruby-keyword">then</span> <span class="ruby-constant">DefaultDHKey2048</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">nil</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:ecdh_curve</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:tmp_ecdh_callback</span>)
      <span class="ruby-identifier">ctx</span>.<span class="ruby-identifier">tmp_ecdh_callback</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
        <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">PKey</span><span class="ruby-operator">::</span><span class="ruby-constant">EC</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:ecdh_curve</span>])
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">ssl_io</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSLSocket</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">selectable</span>, <span class="ruby-identifier">ctx</span>)
  <span class="ruby-identifier">ssl_io</span>.<span class="ruby-identifier">sync_close</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:sni_hostname</span>]
    <span class="ruby-identifier">ssl_io</span>.<span class="ruby-identifier">hostname</span> = <span class="ruby-identifier">tls_parms</span>[<span class="ruby-value">:sni_hostname</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">ssl_io</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:hostname=</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">is_server</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ssl_io</span>.<span class="ruby-identifier">accept_nonblock</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">ssl_io</span>.<span class="ruby-identifier">connect_nonblock</span>
  <span class="ruby-keyword">rescue</span>; <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">selectable</span>.<span class="ruby-identifier">io</span> = <span class="ruby-identifier">ssl_io</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- start_tls-source -->
            
          </div>

          

          
        </div><!-- start_tls-method -->

      
        <div id="start_unix_domain_server-method" class="method-detail ">
          <a name="method-c-start_unix_domain_server"></a>

          
          <div class="method-heading">
            <span class="method-name">start_unix_domain_server</span><span
              class="method-args">(filename, *args, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Start a Unix-domain server.</p>

<p>Note that this is an alias for {<a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a>},
which can be used to start both TCP and Unix-domain servers.</p>

<p>@see <a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a></p>
            

            
            <div class="method-source-code" id="start_unix_domain_server-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 560</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">start_unix_domain_server</span> <span class="ruby-identifier">filename</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-identifier">start_server</span> <span class="ruby-identifier">filename</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- start_unix_domain_server-source -->
            
          </div>

          

          
        </div><!-- start_unix_domain_server-method -->

      
        <div id="start_unix_server-method" class="method-detail ">
          <a name="method-c-start_unix_server"></a>

          
          <div class="method-heading">
            <span class="method-name">start_unix_server</span><span
              class="method-args">(chain)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="start_unix_server-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start_unix_server</span> <span class="ruby-identifier">chain</span>
  (<span class="ruby-identifier">s</span> = <span class="ruby-constant">EvmaUNIXServer</span>.<span class="ruby-identifier">start_server</span> <span class="ruby-identifier">chain</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;no acceptor&quot;</span>
  <span class="ruby-identifier">s</span>.<span class="ruby-identifier">uuid</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- start_unix_server-source -->
            
          </div>

          

          
        </div><!-- start_unix_server-method -->

      
        <div id="stop-method" class="method-detail ">
          <a name="method-c-stop"></a>

          
          <div class="method-heading">
            <span class="method-name">stop</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="stop-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">stop</span>
  <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">stop</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- stop-source -->
            
          </div>

          

          
        </div><!-- stop-method -->

      
        <div id="stop_event_loop-method" class="method-detail ">
          <a name="method-c-stop_event_loop"></a>

          
          <div class="method-heading">
            <span class="method-name">stop_event_loop</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Causes the processing loop to stop executing, which will cause all open
connections and accepting servers to be run down and closed. <a
href="EventMachine/Connection.html">Connection</a> termination callbacks
added using {<a
href="EventMachine.html#method-c-add_shutdown_hook">EventMachine.add_shutdown_hook</a>}
will be called as part of running this method.</p>

<p>When all of this processing is complete, the call to {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>} which started
the processing loop will return and program flow will resume from the
statement following {<a
href="EventMachine.html#method-c-run">EventMachine.run</a>} call.</p>

<p>@example Stopping a running <a href="EventMachine.html">EventMachine</a>
event loop</p>

<pre>require 'rubygems'
require 'eventmachine'

module Redmond
  def post_init
    puts &quot;We're sending a dumb HTTP request to the remote peer.&quot;
    send_data &quot;GET / HTTP/1.1\r\nHost: www.microsoft.com\r\n\r\n&quot;
  end

  def receive_data data
    puts &quot;We received #{data.length} bytes from the remote peer.&quot;
    puts &quot;We're going to stop the event loop now.&quot;
    EventMachine::stop_event_loop
  end

  def unbind
    puts &quot;A connection has terminated.&quot;
  end
end

puts &quot;We're starting the event loop now.&quot;
EventMachine.run {
  EventMachine.connect &quot;www.microsoft.com&quot;, 80, Redmond
}
puts &quot;The event loop has stopped.&quot;

# This program will produce approximately the following output:
#
# We're starting the event loop now.
# We're sending a dumb HTTP request to the remote peer.
# We received 1440 bytes from the remote peer.
# We're going to stop the event loop now.
# A connection has terminated.
# The event loop has stopped.</pre>
            

            
            <div class="method-source-code" id="stop_event_loop-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 416</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stop_event_loop</span>
  <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">stop</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- stop_event_loop-source -->
            
          </div>

          

          
        </div><!-- stop_event_loop-method -->

      
        <div id="stop_server-method" class="method-detail ">
          <a name="method-c-stop_server"></a>

          
          <div class="method-heading">
            <span class="method-name">stop_server</span><span
              class="method-args">(signature)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Stop a TCP server socket that was started with {<a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a>}.
@see <a
href="EventMachine.html#method-c-start_server">EventMachine.start_server</a></p>
            

            
            <div class="method-source-code" id="stop_server-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 550</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stop_server</span> <span class="ruby-identifier">signature</span>
  <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">stop_tcp_server</span> <span class="ruby-identifier">signature</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- stop_server-source -->
            
          </div>

          

          
        </div><!-- stop_server-method -->

      
        <div id="stop_tcp_server-method" class="method-detail ">
          <a name="method-c-stop_tcp_server"></a>

          
          <div class="method-heading">
            <span class="method-name">stop_tcp_server</span><span
              class="method-args">(sig)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="stop_tcp_server-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">stop_tcp_server</span> <span class="ruby-identifier">sig</span>
  <span class="ruby-identifier">s</span> = <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">get_selectable</span>(<span class="ruby-identifier">sig</span>)
  <span class="ruby-identifier">s</span>.<span class="ruby-identifier">schedule_close</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- stop_tcp_server-source -->
            
          </div>

          

          
        </div><!-- stop_tcp_server-method -->

      
        <div id="stopping-3F-method" class="method-detail ">
          <a name="method-c-stopping-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">stopping?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="stopping-3F-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">stopping?</span>
  <span class="ruby-keyword">return</span> <span class="ruby-constant">Reactor</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">stop_scheduled</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- stopping-3F-source -->
            
          </div>

          

          
        </div><!-- stopping-3F-method -->

      
        <div id="system-method" class="method-detail ">
          <a name="method-c-system"></a>

          
          <div class="method-heading">
            <span class="method-name">system</span><span
              class="method-args">(cmd, *args, &cb)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="EventMachine.html#method-c-system">EM::system</a> is a simple
wrapper for <a href="EventMachine.html#method-c-popen">EM::popen</a>. It is
similar to Kernel::system, but requires a single string argument for the
command and performs no shell expansion.</p>

<p>The block or proc passed to <a
href="EventMachine.html#method-c-system">EM::system</a> is called with two
arguments: the output generated by the command, and a Process::Status that
contains information about the command’s execution.</p>

<pre>EM.run{
  EM.system('ls'){ |output,status| puts output if status.exitstatus == 0 }
}</pre>

<p>You can also supply an additional proc to send some data to the process:</p>

<pre>EM.run{
  EM.system('sh', proc{ |process|
    process.send_data(&quot;echo hello\n&quot;)
    process.send_data(&quot;exit\n&quot;)
  }, proc{ |out,status|
    puts(out)
  })
}</pre>

<p>Like <a href="EventMachine.html#method-c-popen">EventMachine.popen</a>, <a
href="EventMachine.html#method-c-system">EventMachine.system</a> currently
does not work on windows. It returns the pid of the spawned process.</p>
            

            
            <div class="method-source-code" id="system-source">
<pre>
<span class="ruby-comment"># File lib/em/processes.rb, line 112</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">system</span> <span class="ruby-identifier">cmd</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">cb</span>
  <span class="ruby-identifier">cb</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">Proc</span>
  <span class="ruby-identifier">init</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">Proc</span>

  <span class="ruby-comment"># merge remaining arguments into the command</span>
  <span class="ruby-identifier">cmd</span> = [<span class="ruby-identifier">cmd</span>, *<span class="ruby-identifier">args</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">any?</span>

  <span class="ruby-constant">EM</span>.<span class="ruby-identifier">get_subprocess_pid</span>(<span class="ruby-constant">EM</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-identifier">cmd</span>, <span class="ruby-constant">SystemCmd</span>, <span class="ruby-identifier">cb</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">init</span>[<span class="ruby-identifier">c</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">init</span>
  <span class="ruby-keyword">end</span>.<span class="ruby-identifier">signature</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- system-source -->
            
          </div>

          

          
        </div><!-- system-method -->

      
        <div id="tick_loop-method" class="method-detail ">
          <a name="method-c-tick_loop"></a>

          
          <div class="method-heading">
            <span class="method-name">tick_loop</span><span
              class="method-args">(*a, &b)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Creates and immediately starts an <a
href="EventMachine/TickLoop.html">EventMachine::TickLoop</a></p>
            

            
            <div class="method-source-code" id="tick_loop-source">
<pre>
<span class="ruby-comment"># File lib/em/tick_loop.rb, line 3</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">tick_loop</span>(*<span class="ruby-identifier">a</span>, &amp;<span class="ruby-identifier">b</span>)
  <span class="ruby-constant">TickLoop</span>.<span class="ruby-identifier">new</span>(*<span class="ruby-identifier">a</span>, &amp;<span class="ruby-identifier">b</span>).<span class="ruby-identifier">start</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- tick_loop-source -->
            
          </div>

          

          
        </div><!-- tick_loop-method -->

      
        <div id="tls_parm_set-3F-method" class="method-detail ">
          <a name="method-c-tls_parm_set-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">tls_parm_set?</span><span
              class="method-args">(parm)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="tls_parm_set-3F-source">
<pre>
<span class="ruby-comment"># File lib/em/pure_ruby.rb, line 249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">tls_parm_set?</span>(<span class="ruby-identifier">parm</span>)
  <span class="ruby-operator">!</span>(<span class="ruby-identifier">parm</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">parm</span>.<span class="ruby-identifier">empty?</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- tls_parm_set-3F-source -->
            
          </div>

          

          
        </div><!-- tls_parm_set-3F-method -->

      
        <div id="watch-method" class="method-detail ">
          <a name="method-c-watch"></a>

          
          <div class="method-heading">
            <span class="method-name">watch</span><span
              class="method-args">(io, handler=nil, *args, &blk)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>{<a href="EventMachine.html#method-c-watch">EventMachine.watch</a>}
registers a given file descriptor or <a href="IO.html">IO</a> object with
the eventloop. The file descriptor will not be modified (it will remain
blocking or non-blocking).</p>

<p>The eventloop can be used to process readable and writable events on the
file descriptor, using {<a
href="EventMachine/Connection.html#method-i-notify_readable-3D">EventMachine::Connection#notify_readable=</a>}
and {<a
href="EventMachine/Connection.html#method-i-notify_writable-3D">EventMachine::Connection#notify_writable=</a>}</p>

<p>{<a
href="EventMachine/Connection.html#method-i-notify_readable-3F">EventMachine::Connection#notify_readable?</a>}
and {<a
href="EventMachine/Connection.html#method-i-notify_writable-3F">EventMachine::Connection#notify_writable?</a>}
can be used to check what events are enabled on the connection.</p>

<p>To detach the file descriptor, use {<a
href="EventMachine/Connection.html#method-i-detach">EventMachine::Connection#detach</a>}</p>

<p>@example</p>

<pre>module SimpleHttpClient
  def notify_readable
    header = @io.readline

    if header == &quot;\r\n&quot;
      # detach returns the file descriptor number (fd == @io.fileno)
      fd = detach
    end
  rescue EOFError
    detach
  end

  def unbind
    EM.next_tick do
      # socket is detached from the eventloop, but still open
      data = @io.read
    end
  end
end

EventMachine.run {
  sock = TCPSocket.new('site.com', 80)
  sock.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
  conn = EventMachine.watch(sock, SimpleHttpClient)
  conn.notify_readable = true
}</pre>

<p>@author Riham Aldakkak (eSpace Technologies)</p>
            

            
            <div class="method-source-code" id="watch-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 730</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">EventMachine</span><span class="ruby-operator">::</span><span class="ruby-identifier">watch</span> <span class="ruby-identifier">io</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">blk</span>
  <span class="ruby-identifier">attach_io</span> <span class="ruby-identifier">io</span>, <span class="ruby-keyword">true</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">blk</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- watch-source -->
            
          </div>

          

          
        </div><!-- watch-method -->

      
        <div id="watch_file-method" class="method-detail ">
          <a name="method-c-watch_file"></a>

          
          <div class="method-heading">
            <span class="method-name">watch_file</span><span
              class="method-args">(filename, handler=nil, *args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>EventMachine’s file monitoring API. Currently supported are the following
events on individual files, using inotify on Linux systems, and kqueue for
*BSD and Mac OS X:</p>
<ul><li>
<p>File modified (written to)</p>
</li><li>
<p>File moved/renamed</p>
</li><li>
<p>File deleted</p>
</li></ul>

<p><a
href="EventMachine.html#method-c-watch_file">EventMachine::watch_file</a>
takes a filename and a handler Module containing your custom callback
methods. This will setup the low level monitoring on the specified file,
and create a new <a
href="EventMachine/FileWatch.html">EventMachine::FileWatch</a> object with
your Module mixed in. <a href="EventMachine/FileWatch.html">FileWatch</a>
is a subclass of {EventMachine::Connection}, so callbacks on this object
work in the familiar way. The callbacks that will be fired by <a
href="EventMachine.html">EventMachine</a> are:</p>
<ul><li>
<p>file_modified</p>
</li><li>
<p>file_moved</p>
</li><li>
<p>file_deleted</p>
</li></ul>

<p>You can access the filename being monitored from within this object using
{<a href="EventMachine/FileWatch.html#method-i-path">FileWatch#path</a>}.</p>

<p>When a file is deleted, {<a
href="EventMachine/FileWatch.html#method-i-stop_watching">FileWatch#stop_watching</a>}
will be called after your file_deleted callback, to clean up the underlying
monitoring and remove EventMachine’s reference to the now-useless
{FileWatch} instance. This will in turn call unbind, if you wish to use it.</p>

<p>The corresponding system-level Errno will be raised when attempting to
monitor non-existent files, files with wrong permissions, or if an error
occurs dealing with inotify/kqueue.</p>

<p>@example</p>

<pre># Before running this example, make sure we have a file to monitor:
# $ echo &quot;bar&quot; &gt; /tmp/foo

module Handler
  def file_modified
    puts &quot;#{path} modified&quot;
  end

  def file_moved
    puts &quot;#{path} moved&quot;
  end

  def file_deleted
    puts &quot;#{path} deleted&quot;
  end

  def unbind
    puts &quot;#{path} monitoring ceased&quot;
  end
end

# for efficient file watching, use kqueue on Mac OS X
EventMachine.kqueue = true if EventMachine.kqueue?

EventMachine.run {
  EventMachine.watch_file(&quot;/tmp/foo&quot;, Handler)
}

# $ echo &quot;baz&quot; &gt;&gt; /tmp/foo    =&gt;    &quot;/tmp/foo modified&quot;
# $ mv /tmp/foo /tmp/oof      =&gt;    &quot;/tmp/foo moved&quot;
# $ rm /tmp/oof               =&gt;    &quot;/tmp/foo deleted&quot;</pre>

<p>@note The ability to pick up on the new filename after a rename is not yet
supported.</p>

<pre>Calling #path will always return the filename you originally used.</pre>

<p>@param [String]        filename Local path to the file to watch. @param
[Class, Module] handler  A class or module that implements event handlers
associated with the file.</p>
            

            
            <div class="method-source-code" id="watch_file-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1308</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">watch_file</span>(<span class="ruby-identifier">filename</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-constant">FileWatch</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>)

  <span class="ruby-identifier">s</span> = <span class="ruby-constant">EM</span><span class="ruby-operator">::</span><span class="ruby-identifier">watch_filename</span>(<span class="ruby-identifier">filename</span>)
  <span class="ruby-identifier">c</span> = <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">s</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-comment"># we have to set the path like this because of how Connection.new works</span>
  <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-string">&quot;@path&quot;</span>, <span class="ruby-identifier">filename</span>)
  <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">block_given?</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">c</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- watch_file-source -->
            
          </div>

          

          
        </div><!-- watch_file-method -->

      
        <div id="watch_process-method" class="method-detail ">
          <a name="method-c-watch_process"></a>

          
          <div class="method-heading">
            <span class="method-name">watch_process</span><span
              class="method-args">(pid, handler=nil, *args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>EventMachine’s process monitoring API. On Mac OS X and *BSD this method is
implemented using kqueue.</p>

<p>@example</p>

<pre>module ProcessWatcher
  def process_exited
    put 'the forked child died!'
  end
end

pid = fork{ sleep }

EventMachine.run {
  EventMachine.watch_process(pid, ProcessWatcher)
  EventMachine.add_timer(1){ Process.kill('TERM', pid) }
}</pre>

<p>@param [Integer]       pid     PID of the process to watch. @param [Class,
Module] handler A class or module that implements event handlers associated
with the file.</p>
            

            
            <div class="method-source-code" id="watch_process-source">
<pre>
<span class="ruby-comment"># File lib/eventmachine.rb, line 1339</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">watch_process</span>(<span class="ruby-identifier">pid</span>, <span class="ruby-identifier">handler</span>=<span class="ruby-keyword">nil</span>, *<span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">pid</span> = <span class="ruby-identifier">pid</span>.<span class="ruby-identifier">to_i</span>

  <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">klass_from_handler</span>(<span class="ruby-constant">ProcessWatch</span>, <span class="ruby-identifier">handler</span>, *<span class="ruby-identifier">args</span>)

  <span class="ruby-identifier">s</span> = <span class="ruby-constant">EM</span><span class="ruby-operator">::</span><span class="ruby-identifier">watch_pid</span>(<span class="ruby-identifier">pid</span>)
  <span class="ruby-identifier">c</span> = <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">s</span>, *<span class="ruby-identifier">args</span>
  <span class="ruby-comment"># we have to set the path like this because of how Connection.new works</span>
  <span class="ruby-identifier">c</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-string">&quot;@pid&quot;</span>, <span class="ruby-identifier">pid</span>)
  <span class="ruby-ivar">@conns</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">block_given?</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">yield</span> <span class="ruby-identifier">c</span>
  <span class="ruby-identifier">c</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- watch_process-source -->
            
          </div>

          

          
        </div><!-- watch_process-method -->

      
        <div id="yield-method" class="method-detail ">
          <a name="method-c-yield"></a>

          
          <div class="method-heading">
            <span class="method-name">yield</span><span
              class="method-args">(&block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="yield-source">
<pre>
<span class="ruby-comment"># File lib/em/spawnable.rb, line 76</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-keyword">yield</span> &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-keyword">return</span> <span class="ruby-constant">YieldBlockFromSpawnedProcess</span>.<span class="ruby-identifier">new</span>( <span class="ruby-identifier">block</span>, <span class="ruby-keyword">false</span> )
<span class="ruby-keyword">end</span></pre>
            </div><!-- yield-source -->
            
          </div>

          

          
        </div><!-- yield-method -->

      
        <div id="yield_and_notify-method" class="method-detail ">
          <a name="method-c-yield_and_notify"></a>

          
          <div class="method-heading">
            <span class="method-name">yield_and_notify</span><span
              class="method-args">(&block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>@private</p>
            

            
            <div class="method-source-code" id="yield_and_notify-source">
<pre>
<span class="ruby-comment"># File lib/em/spawnable.rb, line 81</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">yield_and_notify</span> &amp;<span class="ruby-identifier">block</span>
  <span class="ruby-keyword">return</span> <span class="ruby-constant">YieldBlockFromSpawnedProcess</span>.<span class="ruby-identifier">new</span>( <span class="ruby-identifier">block</span>, <span class="ruby-keyword">true</span> )
<span class="ruby-keyword">end</span></pre>
            </div><!-- yield_and_notify-source -->
            
          </div>

          

          
        </div><!-- yield_and_notify-method -->

      
      </div><!-- public-class-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  

  </div><!-- documentation -->

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

