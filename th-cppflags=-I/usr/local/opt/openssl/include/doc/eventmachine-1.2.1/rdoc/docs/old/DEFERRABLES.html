<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>File: DEFERRABLES [eventmachine-1.2.1 Documentation]</title>

  <link type="text/css" media="screen" href="../../rdoc.css" rel="stylesheet" />

  <script src="../../js/jquery.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../js/thickbox-compressed.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../js/quicksearch.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../js/darkfish.js" type="text/javascript"
    charset="utf-8"></script>
</head>

<body class="file">
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../../index.html">Home</a>
          <a href="../../index.html#classes">Classes</a>
          <a href="../../index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul>
        
          <li class="file"><a href="../../docs/old/ChangeLog.html">ChangeLog</a></li>
        
          <li class="file"><a href="../../docs/old/DEFERRABLES.html">DEFERRABLES</a></li>
        
          <li class="file"><a href="../../docs/old/EPOLL.html">EPOLL</a></li>
        
          <li class="file"><a href="../../docs/old/INSTALL.html">INSTALL</a></li>
        
          <li class="file"><a href="../../docs/old/KEYBOARD.html">KEYBOARD</a></li>
        
          <li class="file"><a href="../../docs/old/LEGAL.html">LEGAL</a></li>
        
          <li class="file"><a href="../../docs/old/LIGHTWEIGHT_CONCURRENCY.html">LIGHTWEIGHT_CONCURRENCY</a></li>
        
          <li class="file"><a href="../../docs/old/PURE_RUBY.html">PURE_RUBY</a></li>
        
          <li class="file"><a href="../../docs/old/RELEASE_NOTES.html">RELEASE_NOTES</a></li>
        
          <li class="file"><a href="../../docs/old/SMTP.html">SMTP</a></li>
        
          <li class="file"><a href="../../docs/old/SPAWNED_PROCESSES.html">SPAWNED_PROCESSES</a></li>
        
          <li class="file"><a href="../../docs/old/TODO.html">TODO</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class Index
          <span class="search-toggle"><img src="../../images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="../../EventMachine.html">EventMachine</a></li>
        
          <li><a href="../../EventMachine.html">EventMachine</a></li>
        
          <li><a href="../../EventMachine/CertificateCreator.html">EventMachine::CertificateCreator</a></li>
        
          <li><a href="../../EventMachine/Channel.html">EventMachine::Channel</a></li>
        
          <li><a href="../../EventMachine/Completion.html">EventMachine::Completion</a></li>
        
          <li><a href="../../EventMachine/Connection.html">EventMachine::Connection</a></li>
        
          <li><a href="../../EventMachine/ConnectionError.html">EventMachine::ConnectionError</a></li>
        
          <li><a href="../../EventMachine/ConnectionNotBound.html">EventMachine::ConnectionNotBound</a></li>
        
          <li><a href="../../EventMachine/DNS.html">EventMachine::DNS</a></li>
        
          <li><a href="../../EventMachine/DNS/Request.html">EventMachine::DNS::Request</a></li>
        
          <li><a href="../../EventMachine/DNS/RequestIdAlreadyUsed.html">EventMachine::DNS::RequestIdAlreadyUsed</a></li>
        
          <li><a href="../../EventMachine/DNS/Resolver.html">EventMachine::DNS::Resolver</a></li>
        
          <li><a href="../../EventMachine/DNS/Socket.html">EventMachine::DNS::Socket</a></li>
        
          <li><a href="../../EventMachine/DatagramObject.html">EventMachine::DatagramObject</a></li>
        
          <li><a href="../../EventMachine/DefaultDeferrable.html">EventMachine::DefaultDeferrable</a></li>
        
          <li><a href="../../EventMachine/Deferrable.html">EventMachine::Deferrable</a></li>
        
          <li><a href="../../EventMachine/DeferrableChildProcess.html">EventMachine::DeferrableChildProcess</a></li>
        
          <li><a href="../../EventMachine/Error.html">EventMachine::Error</a></li>
        
          <li><a href="../../EventMachine/EvmaKeyboard.html">EventMachine::EvmaKeyboard</a></li>
        
          <li><a href="../../EventMachine/EvmaTCPClient.html">EventMachine::EvmaTCPClient</a></li>
        
          <li><a href="../../EventMachine/EvmaTCPServer.html">EventMachine::EvmaTCPServer</a></li>
        
          <li><a href="../../EventMachine/EvmaUDPSocket.html">EventMachine::EvmaUDPSocket</a></li>
        
          <li><a href="../../EventMachine/EvmaUNIXClient.html">EventMachine::EvmaUNIXClient</a></li>
        
          <li><a href="../../EventMachine/EvmaUNIXServer.html">EventMachine::EvmaUNIXServer</a></li>
        
          <li><a href="../../EventMachine/FileNotFoundException.html">EventMachine::FileNotFoundException</a></li>
        
          <li><a href="../../EventMachine/FileStreamer.html">EventMachine::FileStreamer</a></li>
        
          <li><a href="../../EventMachine/FileWatch.html">EventMachine::FileWatch</a></li>
        
          <li><a href="../../EventMachine/Iterator.html">EventMachine::Iterator</a></li>
        
          <li><a href="../../EventMachine/LoopbreakReader.html">EventMachine::LoopbreakReader</a></li>
        
          <li><a href="../../EventMachine/PeriodicTimer.html">EventMachine::PeriodicTimer</a></li>
        
          <li><a href="../../EventMachine/Pool.html">EventMachine::Pool</a></li>
        
          <li><a href="../../EventMachine/ProcessWatch.html">EventMachine::ProcessWatch</a></li>
        
          <li><a href="../../EventMachine/Protocols.html">EventMachine::Protocols</a></li>
        
          <li><a href="../../EventMachine/Protocols.html">EventMachine::Protocols</a></li>
        
          <li><a href="../../EventMachine/Protocols/HeaderAndContentProtocol.html">EventMachine::Protocols::HeaderAndContentProtocol</a></li>
        
          <li><a href="../../EventMachine/Protocols/HttpClient.html">EventMachine::Protocols::HttpClient</a></li>
        
          <li><a href="../../EventMachine/Protocols/HttpClient2.html">EventMachine::Protocols::HttpClient2</a></li>
        
          <li><a href="../../EventMachine/Protocols/HttpClient2/Request.html">EventMachine::Protocols::HttpClient2::Request</a></li>
        
          <li><a href="../../EventMachine/Protocols/LineAndTextProtocol.html">EventMachine::Protocols::LineAndTextProtocol</a></li>
        
          <li><a href="../../EventMachine/Protocols/LineProtocol.html">EventMachine::Protocols::LineProtocol</a></li>
        
          <li><a href="../../EventMachine/Protocols/LineText2.html">EventMachine::Protocols::LineText2</a></li>
        
          <li><a href="../../EventMachine/Protocols/Memcache.html">EventMachine::Protocols::Memcache</a></li>
        
          <li><a href="../../EventMachine/Protocols/Memcache/ParserError.html">EventMachine::Protocols::Memcache::ParserError</a></li>
        
          <li><a href="../../EventMachine/Protocols/ObjectProtocol.html">EventMachine::Protocols::ObjectProtocol</a></li>
        
          <li><a href="../../EventMachine/Protocols/Postgres3.html">EventMachine::Protocols::Postgres3</a></li>
        
          <li><a href="../../EventMachine/Protocols/SASLauth.html">EventMachine::Protocols::SASLauth</a></li>
        
          <li><a href="../../EventMachine/Protocols/SASLauthclient.html">EventMachine::Protocols::SASLauthclient</a></li>
        
          <li><a href="../../EventMachine/Protocols/SmtpClient.html">EventMachine::Protocols::SmtpClient</a></li>
        
          <li><a href="../../EventMachine/Protocols/SmtpServer.html">EventMachine::Protocols::SmtpServer</a></li>
        
          <li><a href="../../EventMachine/Protocols/Socks4.html">EventMachine::Protocols::Socks4</a></li>
        
          <li><a href="../../EventMachine/Protocols/Stomp.html">EventMachine::Protocols::Stomp</a></li>
        
          <li><a href="../../EventMachine/Protocols/Stomp/Message.html">EventMachine::Protocols::Stomp::Message</a></li>
        
          <li><a href="../../EventMachine/Protocols/TcpConnectTester.html">EventMachine::Protocols::TcpConnectTester</a></li>
        
          <li><a href="../../EventMachine/Queue.html">EventMachine::Queue</a></li>
        
          <li><a href="../../EventMachine/Reactor.html">EventMachine::Reactor</a></li>
        
          <li><a href="../../EventMachine/Selectable.html">EventMachine::Selectable</a></li>
        
          <li><a href="../../EventMachine/SpawnedProcess.html">EventMachine::SpawnedProcess</a></li>
        
          <li><a href="../../EventMachine/StreamObject.html">EventMachine::StreamObject</a></li>
        
          <li><a href="../../EventMachine/SystemCmd.html">EventMachine::SystemCmd</a></li>
        
          <li><a href="../../EventMachine/ThreadedResource.html">EventMachine::ThreadedResource</a></li>
        
          <li><a href="../../EventMachine/TickLoop.html">EventMachine::TickLoop</a></li>
        
          <li><a href="../../EventMachine/Timer.html">EventMachine::Timer</a></li>
        
          <li><a href="../../EventMachine/UnknownTimerFired.html">EventMachine::UnknownTimerFired</a></li>
        
          <li><a href="../../EventMachine/Unsupported.html">EventMachine::Unsupported</a></li>
        
          <li><a href="../../EventMachine/UuidGenerator.html">EventMachine::UuidGenerator</a></li>
        
          <li><a href="../../EventMachine/YieldBlockFromSpawnedProcess.html">EventMachine::YieldBlockFromSpawnedProcess</a></li>
        
          <li><a href="../../Object.html">Object</a></li>
        
          <li><a href="../../EventMachine.html">Object::EM</a></li>
        
          <li><a href="../../EventMachine/Protocols.html">Object::P</a></li>
        
          <li><a href="../../BufferedTokenizer.html">BufferedTokenizer</a></li>
        
          <li><a href="../../IO.html">IO</a></li>
        
          <li><a href="../../StringIO.html">StringIO</a></li>
        
          <li><a href="../../TestConnection.html">TestConnection</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    
<p><a href="../../EventMachine.html">EventMachine</a> (<a
href="../../EventMachine.html">EM</a>) adds two different formalisms for
lightweight concurrency to the Ruby programmer's toolbox: spawned processes
and deferrables. This note will show you how to use deferrables. For more
information, see the separate document LIGHTWEIGHT_CONCURRENCY.</p>

<h3>What are Deferrables?</h3>

<p>EventMachine’s Deferrable borrows heavily from the “deferred” object in
Python’s “Twisted” event-handling framework. Here’s a minimal example that
illustrates Deferrable:</p>

<pre>require 'eventmachine'

class MyClass
  include EM::Deferrable

  def print_value x
    puts &quot;MyClass instance received #{x}&quot;
  end
end

EM.run {
  df = MyClass.new
  df.callback {|x|
    df.print_value(x)
    EM.stop
  }

  EM::Timer.new(2) {
    df.set_deferred_status :succeeded, 100
  }
}</pre>

<p>This program will spin for two seconds, print out the string “MyClass
instance received 100” and then exit. The Deferrable pattern relies on an
unusual metaphor that may be unfamiliar to you, unless you’ve used Python’s
Twisted. You may need to read the following material through more than once
before you get the idea.</p>

<p><a href="../../EventMachine/Deferrable.html">EventMachine::Deferrable</a>
is simply a Ruby Module that you can include in your own classes. (There
also is a class named <a
href="../../EventMachine/DefaultDeferrable.html">EventMachine::DefaultDeferrable</a>
for when you want to create one without including it in code of your own.)</p>

<p>An object that includes <a
href="../../EventMachine/Deferrable.html">EventMachine::Deferrable</a> is
like any other Ruby object: it can be created whenever you want, returned
from your functions, or passed as an argument to other functions.</p>

<p>The Deferrable pattern allows you to specify any number of Ruby code blocks
(callbacks or errbacks) that will be executed at some future time when the
status of the Deferrable object changes.</p>

<p>How might that be useful? Well, imagine that you’re implementing an HTTP
server, but you need to make a call to some other server in order to
fulfill a client request.</p>

<p>When you receive a request from one of your clients, you can create and
return a Deferrable object. Some other section of your program can add a
callback to the Deferrable that will cause the client’s request to be
fulfilled. Simultaneously, you initiate an event-driven or threaded client
request to some different server. And then your <a
href="../../EventMachine.html">EM</a> program will continue to process
other events and service other client requests.</p>

<p>When your client request to the other server completes some time later, you
will call the set_deferred_status method on the Deferrable object, passing
either a success or failure status, and an arbitrary number of parameters
(which might include the data you received from the other server).</p>

<p>At that point, the status of the Deferrable object becomes known, and its
callback or errback methods are immediately executed. Callbacks and
errbacks are code blocks that are attached to Deferrable objects at any
time through the methods callback and errback.</p>

<p>The deep beauty of this pattern is that it decouples the disposition of one
operation (such as a client request to an outboard server) from the
subsequent operations that depend on that disposition (which may include
responding to a different client or any other operation).</p>

<p>The code which invokes the deferred operation (that will eventually result
in a success or failure status together with associated data) is completely
separate from the code which depends on that status and data. This achieves
one of the primary goals for which threading is typically used in
sophisticated applications, with none of the nondeterminacy or debugging
difficulties of threads.</p>

<p>As soon as the deferred status of a Deferrable becomes known by way of a
call to set_deferred_status, the Deferrable will IMMEDIATELY execute all of
its callbacks or errbacks in the order in which they were added to the
Deferrable.</p>

<p>Callbacks and errbacks can be added to a Deferrable object at any time, not
just when the object is created. They can even be added after the status of
the object has been determined! (In this case, they will be executed
immediately when they are added.)</p>

<p>A call to Deferrable#set_deferred_status takes :succeeded or :failed as its
first argument. (This determines whether the object will call its callbacks
or its errbacks.) set_deferred_status also takes zero or more additional
parameters, that will in turn be passed as parameters to the callbacks or
errbacks.</p>

<p>In general, you can only call set_deferred_status ONCE on a Deferrable
object. A call to set_deferred_status will not return until all of the
associated callbacks or errbacks have been called. If you add callbacks or
errbacks AFTER making a call to set_deferred_status, those additional
callbacks or errbacks will execute IMMEDIATELY. Any given callback or
errback will be executed AT MOST once.</p>

<p>It’s possible to call set_deferred_status AGAIN, during the execution a
callback or errback. This makes it possible to change the parameters which
will be sent to the callbacks or errbacks farther down the chain, enabling
some extremely elegant use-cases. You can transform the data returned from
a deferred operation in arbitrary ways as needed by subsequent users,
without changing any of the code that generated the original data.</p>

<p>A call to set_deferred_status will not return until all of the associated
callbacks or errbacks have been called. If you add callbacks or errbacks
AFTER making a call to set_deferred_status, those additional callbacks or
errbacks will execute IMMEDIATELY.</p>

<p>Let’s look at some more sample code. It turns out that many of the internal
protocol implementations in the <a
href="../../EventMachine.html">EventMachine</a> package rely on Deferrable.
One of these is <a
href="../../EventMachine/Protocols/HttpClient.html">EM::Protocols::HttpClient</a>.</p>

<p>To make an evented HTTP request, use the module function
EM::Protocols::HttpClient#request, which returns a Deferrable object.
Here’s how:</p>

<pre>require 'eventmachine'

EM.run {
  df = EM::Protocols::HttpClient.request( :host=&gt;&quot;www.example.com&quot;,
                                          :request=&gt;&quot;/index.html&quot; )

  df.callback {|response|
    puts &quot;Succeeded: #{response[:content]}&quot;
    EM.stop
  }

  df.errback {|response|
    puts &quot;ERROR: #{response[:status]}&quot;
    EM.stop
  }
}</pre>

<p>(See the documentation of <a
href="../../EventMachine/Protocols/HttpClient.html">EventMachine::Protocols::HttpClient</a>
for information on the object returned by request.)</p>

<p>In this code, we make a call to HttpClient#request, which immediately
returns a Deferrable object. In the background, an HTTP client request is
being made to <a href="http://www.example.com">www.example.com</a>,
although your code will continue to run concurrently.</p>

<p>At some future point, the HTTP client request will complete, and the code
in <a
href="../../EventMachine/Protocols/HttpClient.html">EM::Protocols::HttpClient</a>
will process either a valid HTTP response (including returned content), or
an error.</p>

<p>At that point, <a
href="../../EventMachine/Protocols/HttpClient.html">EM::Protocols::HttpClient</a>
will call <a
href="../../EventMachine/Deferrable.html#method-i-set_deferred_status">EM::Deferrable#set_deferred_status</a>
on the Deferrable object that was returned to your program, as the return
value from <a
href="../../EventMachine/Protocols/HttpClient.html#method-c-request">EM::Protocols::HttpClient.request</a>.
You don’t have to do anything to make this happen. All you have to do is
tell the Deferrable what to do in case of either success, failure, or both.</p>

<p>In our code sample, we set one callback and one errback. The former will be
called if the HTTP call succeeds, and the latter if it fails. (For
simplicity, we have both of them calling EM#stop to end the program,
although real programs would be very unlikely to do this.)</p>

<p>Setting callbacks and errbacks is optional. They are handlers to defined
events in the lifecycle of the Deferrable event. It’s not an error if you
fail to set either a callback, an errback, or both. But of course your
program will then fail to receive those notifications.</p>

<p>If through some bug it turns out that set_deferred_status is never called
on a Deferrable object, then that object’s callbacks or errbacks will NEVER
be called. It’s also possible to set a timeout on a Deferrable. If the
timeout elapses before any other call to set_deferred_status, the
Deferrable object will behave as is you had called
set_deferred_status(:failed) on it.</p>

<p>Now let’s modify the example to illustrate some additional points:</p>

<pre>require 'eventmachine'

EM.run {
  df = EM::Protocols::HttpClient.request( :host=&gt;&quot;www.example.com&quot;,
                                          :request=&gt;&quot;/index.html&quot; )

  df.callback {|response|
    df.set_deferred_status :succeeded, response[:content]
  }

  df.callback {|string|
    puts &quot;Succeeded: #{string}&quot;
    EM.stop
  }

  df.errback {|response|
    puts &quot;ERROR: #{response[:status]}&quot;
    EM.stop
  }
}</pre>

<p>Just for the sake of illustration, we’ve now set two callbacks instead of
one. If the deferrable operation (the HTTP client-request) succeeds, then
both of the callbacks will be executed in order.</p>

<p>But notice that we’ve also made our own call to set_deferred_status in the
first callback. This isn’t required, because the HttpClient implementation
already made a call to set_deferred_status. (Otherwise, of course, the
callback would not be executing.)</p>

<p>But we used set_deferred_status in the first callback in order to change
the parameters that will be sent to subsequent callbacks in the chain. In
this way, you can construct powerful sequences of layered functionality. If
you want, you can even change the status of the Deferrable from :succeeded
to :failed, which would abort the chain of callback calls, and invoke the
chain of errbacks instead.</p>

<p>Now of course it’s somewhat trivial to define two callbacks in the same
method, even with the parameter-changing effect we just described. It would
be much more interesting to pass the Deferrable to some other function (for
example, a function defined in another module or a different gem), that
would in turn add callbacks and/or errbacks of its own. That would
illustrate the true power of the Deferrable pattern: to isolate the HTTP
client-request from other functions that use the data that it returns
without caring where those data came from.</p>

<p>Remember that you can add a callback or an errback to a Deferrable at any
point in time, regardless of whether the status of the deferred operation
is known (more precisely, regardless of when set_deferred_status is called
on the object). Even hours or days later.</p>

<p>When you add a callback or errback to a Deferrable object on which
set_deferred_status has not yet been called, the callback/errback is queued
up for future execution, inside the Deferrable object. When you add a
callback or errback to a Deferrable on which set_deferred_status has
already been called, the callback/errback will be executed immediately.
Your code doesn’t have to worry about the ordering, and there are no timing
issues, as there would be with a threaded approach.</p>

<p>For more information on Deferrables and their typical usage patterns, look
in the <a href="../../EventMachine.html">EM</a> unit tests. There are also
quite a few sugarings (including EM::Deferrable#future) that make typical
Deferrable usages syntactically easier to work with.</p>

  </div>

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>
</body>
</html>

