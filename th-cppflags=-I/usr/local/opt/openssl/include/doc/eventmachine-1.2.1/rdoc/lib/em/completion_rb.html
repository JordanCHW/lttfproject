<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>File: completion.rb [eventmachine-1.2.1 Documentation]</title>

  <link type="text/css" media="screen" href="../../rdoc.css" rel="stylesheet" />

  <script src="../../js/jquery.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../js/thickbox-compressed.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../js/quicksearch.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="../../js/darkfish.js" type="text/javascript"
    charset="utf-8"></script>
</head>

<body class="file file-popup">
  <div id="metadata">
    <dl>
      <dt class="modified-date">Last Modified</dt>
      <dd class="modified-date">2016-12-28 19:23:14 +0800</dd>

      
      <dt class="requires">Requires</dt>
      <dd class="requires">
        <ul>
        
        </ul>
      </dd>
      

      
    </dl>
  </div>

  <div id="documentation">
    
    <div class="description">
      <h2>Description</h2>
      
<h1><a href="../../EventMachine/Completion.html">EM::Completion</a></h1>

<p>A completion is a callback container for various states of completion. In
its most basic form it has a start state and a finish state.</p>

<p>This implementation includes some hold-back from the <a
href="../../EventMachine/Deferrable.html">EM::Deferrable</a> interface in
order to be compatible - but it has a much cleaner implementation.</p>

<p>In general it is preferred that this implementation be used as a state
callback container than <a
href="../../EventMachine/DefaultDeferrable.html">EM::DefaultDeferrable</a>
or other classes including <a
href="../../EventMachine/Deferrable.html">EM::Deferrable</a>. This is
because it is generally more sane to keep this level of state in a
dedicated state-back container. This generally leads to more malleable
interfaces and software designs, as well as eradicating nasty bugs that
result from abstraction leakage.</p>

<h2>Basic Usage</h2>

<p>As already mentioned, the basic usage of a Completion is simply for its two
final states, :succeeded and :failed.</p>

<p>An asynchronous operation will complete at some future point in time, and
users often want to react to this event. API authors will want to expose
some common interface to react to these events.</p>

<p>In the following example, the user wants to know when a short lived
connection has completed its exchange with the remote server. The simple
protocol just waits for an ack to its message.</p>

<pre>class Protocol &lt; EM::Connection
  include EM::P::LineText2

  def initialize(message, completion)
    @message, @completion = message, completion
    @completion.completion { close_connection }
    @completion.timeout(1, :timeout)
  end

  def post_init
    send_data(@message)
  end

  def receive_line(line)
    case line
    when /ACK/i
      @completion.succeed line
    when /ERR/i
      @completion.fail :error, line
    else
      @completion.fail :unknown, line
    end
  end

  def unbind
    @completion.fail :disconnected unless @completion.completed?
  end
end

class API
  attr_reader :host, :port

  def initialize(host = 'example.org', port = 8000)
    @host, @port = host, port
  end

  def request(message)
    completion = EM::Deferrable::Completion.new
    EM.connect(host, port, Protocol, message, completion)
    completion
  end
end

api = API.new
completion = api.request('stuff')
completion.callback do |line|
  puts &quot;API responded with: #{line}&quot;
end
completion.errback do |type, line|
  case type
  when :error
    puts &quot;API error: #{line}&quot;
  when :unknown
    puts &quot;API returned unknown response: #{line}&quot;
  when :disconnected
    puts &quot;API server disconnected prematurely&quot;
  when :timeout
    puts &quot;API server did not respond in a timely fashion&quot;
  end
end</pre>

<h2>Advanced Usage</h2>

<p>This completion implementation also supports more state callbacks and
arbitrary states (unlike the original Deferrable API). This allows for
basic stateful process encapsulation. One might use this to setup state
callbacks for various states in an exchange like in the basic usage
example, except where the applicaiton could be made to react to “connected”
and “disconnected” states additionally.</p>

<pre>class Protocol &lt; EM::Connection
  def initialize(completion)
    @response = []
    @completion = completion
    @completion.stateback(:disconnected) do
      @completion.succeed @response.join
    end
  end

  def connection_completed
    @host, @port = Socket.unpack_sockaddr_in get_peername
    @completion.change_state(:connected, @host, @port)
    send_data(&quot;GET http://example.org/ HTTP/1.0\r\n\r\n&quot;)
  end

  def receive_data(data)
    @response &lt;&lt; data
  end

  def unbind
    @completion.change_state(:disconnected, @host, @port)
  end
end

completion = EM::Deferrable::Completion.new
completion.stateback(:connected) do |host, port|
  puts &quot;Connected to #{host}:#{port}&quot;
end
completion.stateback(:disconnected) do |host, port|
  puts &quot;Disconnected from #{host}:#{port}&quot;
end
completion.callback do |response|
  puts response
end

EM.connect('example.org', 80, Protocol, completion)</pre>

<h2>Timeout</h2>

<p>The Completion also has a timeout. The timeout is global and is not aware
of states apart from completion states. The timeout is only engaged if
timeout is called, and it will call fail if it is reached.</p>

<h2>Completion states</h2>

<p>By default there are two completion states, :succeeded and :failed. These
states can be modified by subclassing and overrding the completion_states
method. Completion states are special, in that callbacks for all completion
states are explcitly cleared when a completion state is entered. This
prevents errors that could arise from accidental unterminated timeouts, and
other such user errors.</p>

<h2>Other notes</h2>

<p>Several APIs have been carried over from <a
href="../../EventMachine/Deferrable.html">EM::Deferrable</a> for
compatibility reasons during a transitionary period. Specifically
cancel_errback and cancel_callback are implemented, but their usage is to
be strongly discouraged. Due to the already complex nature of reaction
systems, dynamic callback deletion only makes the problem much worse. It is
always better to add correct conditionals to the callback code, or use more
states, than to address such implementaiton issues with conditional
callbacks.</p>

    </div>
    
  </div>
</body>
</html>

